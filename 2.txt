ASP.Net core
В папке Services опишите класс MemoryCetegoryService, реализующий 
интерфейс ICategoryService. Это сервис, имитирующий работу с реальными 
данными. Метод GetCategoryListAsync должен вернуть коллекцию 
объектов класса Category: 
public class MemoryCategoryService : ICategoryService 
{      
    public Task<ResponseData<List<Category>>> 
GetCategoryListAsync() 
    { 
        var categories = new List<Category> 
        { 
            new Category {Id=1, Name="Стартеры", 
   NormalizedName="starters"}, 
            new Category {Id=2, Name="Салаты", 
NormalizedName="salads"}, 
            . . . 
        }; 
        var result = new ResponseData<List<Category>>(); 
        result.Data=categories; 
        return Task.FromResult(result); 
    } 
} 

using LabUI.Models;
using LabUI.Services.Contracts;

namespace LabUI.Services
{
    public class MemoryCategoryService : ICategoryService
    {
        public Task<ResponseData<List<Category>>> GetCategoryListAsync()
        {
            var categories = new List<Category> 
            { 
            new Category {Id=1, Name="Стартеры",NormalizedName ="starters"}, 
            new Category {Id=2, Name="Салаты", NormalizedName ="salads"}
            
            }; 
        }
        var result = new ResponseData<List<Category>>();
        result.Data=categories; 
        return Task.FromResult(result); 

    }
        
}
В вашем коде есть несколько синтаксических ошибок. Вот исправленная версия класса MemoryCategoryService:

csharp
using LabUI.Models;
using LabUI.Services.Contracts;
using System.Collections.Generic;
using System.Threading.Tasks;

namespace LabUI.Services
{
    public class MemoryCategoryService : ICategoryService
    {
        public Task<ResponseData<List<Category>>> GetCategoryListAsync()
        {
            var categories = new List<Category> 
            { 
                new Category { Id = 1, Name = "Стартеры", NormalizedName = "starters" }, 
                new Category { Id = 2, Name = "Салаты", NormalizedName = "salads" },
                new Category { Id = 3, Name = "Основные блюда", NormalizedName = "main-courses" },
                new Category { Id = 4, Name = "Десерты", NormalizedName = "desserts" },
                new Category { Id = 5, Name = "Напитки", NormalizedName = "drinks" }
            }; 
            
            var result = new ResponseData<List<Category>>();
            result.Data = categories; 
            return Task.FromResult(result); 
        }
    }
}
Основные исправления:

Убрана лишняя закрывающая фигурная скобка после инициализации списка категорий

Добавлены недостающие using-директивы:

System.Collections.Generic - для работы с List<T>

System.Threading.Tasks - для работы с Task

Добавлены дополнительные категории для примера (вы можете изменить их по своему усмотрению)

Исправлено форматирование для лучшей читаемости

Примечания:

Убедитесь, что класс Category и ResponseData<T> определены в пространстве имен LabUI.Models

Убедитесь, что интерфейс ICategoryService определен в LabUI.Services.Contracts и содержит метод GetCategoryListAsync()

Метод Task.FromResult(result) используется для создания завершенной задачи с результатом, что подходит для синхронной реализации в имитационном сервисе

Если вам нужно добавить больше категорий, просто продолжайте список в фигурных скобках, добавляя новые объекты Category.

using LabUI.Models;

namespace LabUI.Services.Contracts
{
    public interface IProductService
    {
        /// <summary> 
        /// Получение списка всех объектов 
        /// </summary> 
        /// <param name="categoryNormalizedName">нормализованное имя категории для фильтрации</param>
    /// <param name="pageNo">номер страницы списка</param> 
    /// <returns></returns> 
    public Task<ResponseData<ListModel<Dish>>> GetProductListAsync(string? categoryNormalizedName, int pageNo = 1);

        /// <summary> 
        /// Поиск объекта по Id 
        /// </summary> 
        /// <param name="id">Идентификатор объекта</param> 
        /// <returns>Найденный объект или null, если объект не найден</returns> 
        public Task<ResponseData<Dish>> GetProductByIdAsync(int id);

        /// <summary> 
        /// Обновление объекта 
        /// </summary> 
        /// <param name="id">Id изменяемомго объекта</param> 
        /// <param name="product">объект с новыми параметрами</param> 
        /// <param name="formFile">Файл изображения</param> 
        /// <returns></returns> 
        public Task UpdateProductAsync(int id, Dish product, IFormFile? formFile);
        /// <summary> 
        /// Удаление объекта 
        /// </summary> 
        /// <param name="id">Id удаляемомго объекта</param> 
        /// <returns></returns> 
        public Task DeleteProductAsync(int id);
        /// <summary> 
        /// Создание объекта 
        /// </summary> 
        /// <param name="product">Новый объект</param> 
        /// <param name="formFile">Файл изображения</param> 
        /// <returns>Созданный объект</returns> 
        public Task<ResponseData<Dish>> CreateProductAsync(Dish product, IFormFile?
    formFile);
    }

}
ошибка
Severity	Code	Description	Project	File	Line	Suppression State	Details
Error (active)	CS0246	The type or namespace name 'Dish' could not be found (are you missing a using directive or an assembly reference?)	LabUI	C:\Users\Alex\Desktop\BSUIR\WT\Labs4\LabUI\Services\Contracts\ICategoryService.cs	13
Ошибка указывает, что тип Dish не найден. Вам нужно либо добавить соответствующее пространство имен, либо изменить тип на правильный. Вот возможные решения:

Вариант 1: Добавьте using директиву для пространства имен, где находится класс Dish
csharp
using LabUI.Models;
using Microsoft.AspNetCore.Http; // Добавьте это для IFormFile

namespace LabUI.Services.Contracts
{
    public interface IProductService
    {
        /// <summary> 
        /// Получение списка всех объектов 
        /// </summary> 
        /// <param name="categoryNormalizedName">нормализованное имя категории для фильтрации</param>
        /// <param name="pageNo">номер страницы списка</param> 
        /// <returns></returns> 
        public Task<ResponseData<ListModel<Dish>>> GetProductListAsync(string? categoryNormalizedName, int pageNo = 1);

        /// <summary> 
        /// Поиск объекта по Id 
        /// </summary> 
        /// <param name="id">Идентификатор объекта</param> 
        /// <returns>Найденный объект или null, если объект не найден</returns> 
        public Task<ResponseData<Dish>> GetProductByIdAsync(int id);

        /// <summary> 
        /// Обновление объекта 
        /// </summary> 
        /// <param name="id">Id изменяемомго объекта</param> 
        /// <param name="product">объект с новыми параметрами</param> 
        /// <param name="formFile">Файл изображения</param> 
        /// <returns></returns> 
        public Task UpdateProductAsync(int id, Dish product, IFormFile? formFile);
        
        /// <summary> 
        /// Удаление объекта 
        /// </summary> 
        /// <param name="id">Id удаляемомго объекта</param> 
        /// <returns></returns> 
        public Task DeleteProductAsync(int id);
        
        /// <summary> 
        /// Создание объекта 
        /// </summary> 
        /// <param name="product">Новый объект</param> 
        /// <param name="formFile">Файл изображения</param> 
        /// <returns>Созданный объект</returns> 
        public Task<ResponseData<Dish>> CreateProductAsync(Dish product, IFormFile? formFile);
    }
}
Вариант 2: Если класс Dish не существует, создайте его
Создайте класс Dish в папке Models:

csharp
// Models/Dish.cs
using System.ComponentModel.DataAnnotations;

namespace LabUI.Models
{
    public class Dish
    {
        public int Id { get; set; }
        
        [Required]
        public string Name { get; set; } = string.Empty;
        
        public string? Description { get; set; }
        
        [Range(0.01, double.MaxValue)]
        public decimal Price { get; set; }
        
        public string? ImageUrl { get; set; }
        
        public int CategoryId { get; set; }
        public Category? Category { get; set; }
        
        public string NormalizedName { get; set; } = string.Empty;
    }
}
Вариант 3: Если нужен класс ListModel, создайте и его
csharp
// Models/ListModel.cs
namespace LabUI.Models
{
    public class ListModel<T>
    {
        public List<T> Items { get; set; } = new List<T>();
        public int TotalCount { get; set; }
        public int CurrentPage { get; set; }
        public int TotalPages { get; set; }
    }
}
Дополнительно: Создайте класс ResponseData если его нет
csharp
// Models/ResponseData.cs
namespace LabUI.Models
{
    public class ResponseData<T>
    {
        public T? Data { get; set; }
        public string? ErrorMessage { get; set; }
        public bool Success => string.IsNullOrEmpty(ErrorMessage);
    }
}
Основные проблемы в вашем коде:

Отсутствует using для Microsoft.AspNetCore.Http - нужно для IFormFile

Не определен класс Dish - нужно создать его в пространстве имен LabUI.Models

Не определен класс ListModel<T> - нужно создать его если используется

После добавления всех необходимых классов и using директив, ошибка должна исчезнуть.

Передача данных представлению. Передача файлов. 
 
1.  Цель работы. 
Дальнейшее изучение механизма передачи данных представлению. 
Изучение работы с файлами в ASP.NET Core. 
 
2.  Общие сведения. 
2.1.  Работа со статическими файлами 
Статические файлы, такие как HTML, CSS, изображения и JavaScript, 
приложение ASP.NET Core может предоставлять непосредственно клиенту. 
Статические файлы как правило располагаются по пути Web Root: 
    <content-root>/wwwroot 
В качестве Content-root обычно выбирается папка, в которой 
размещены все файлы проекта 
Возможность работы со статическими файлами задается в Program: 
app.UseStaticFiles(); 
 
Пример доступа к файлу <content-root>/wwwroot/css/site.css: 
<link asp-href-include="/css/site.css" rel="stylesheet" /> 
 
Для работы с файлами в ASP.NET Core используются поставщики 
файлов (file providers). 
Поставщики файлов - это абстракция над файловыми системами. 
Основным интерфейсом является IFileProvider.  
IFileProvider предоставляет методы для получения информации о 
файлах (IFileInfo), информации о каталоге (IDirectoryContents) и настройке 
уведомлений об изменениях (с использованием IChangeToken). 
IFileInfo предоставляет методы и свойства отдельных файлов или 
каталогов. Он имеет два булевых свойства: Exists и IsDirectory, а также 
свойства, описывающие имя файла, длину (в байтах) и дату LastModified.  
Читать из файла можно с помощью метода CreateReadStream. 
Конкретной реализации интерфейса IFileProvider является 
PhysicalFileProvider, который обеспечивает доступ к физической файловой 
системе. Он обертывает тип System.IO.File (для физического поставщика), 
просматривая все пути к каталогу и его дочерним элементам. Это 
ограничивает доступ только к определенному каталогу и его дочерним 
элементам, предотвращая доступ к файловой системе за пределами этой 
границы. 
Готовые провайдеры для Content_Root и Web_Root можно получить из 
объекта IWebHostEnvironment: 
public HomeController(IWebHostEnvironment env) 
{ 
    var webRootFileProvider = env.WebRootFileProvider; 
    var conentRootFileProvider = env.ContentRootFileProvider; 
}; 
2.1.  Передача файлов на сервер 
Чтобы поддерживать загрузку файлов, HTML-форма должна иметь 
атрибут  
    enctype="multipart/form-data" 
Доступ к отдельным файлам, загруженным на сервер, можно получить 
через привязку модели с использованием интерфейса IFormFile. 
Интерфейс IFormFile описывает следующие методы и свойства: 
public interface IFormFile 
{ 
  string ContentType { get; } 
  string ContentDisposition { get; } 
  IHeaderDictionary Headers { get; } 
  long Length { get; } 
  string Name { get; } 
 string FileName { get; } 
  Stream OpenReadStream(); 
  void CopyTo(Stream target); 
  Task CopyToAsync(Stream target,   
CancellationToken cancellationToken = null); 
} 
Пример сохранения файла в папке «wwwroot/Files»: 
[HttpPost] 
public async Task<IActionResult> Upload( 
                [FromServices] IWebHostEnvironment env, 
                [FromForm] IFormFile uploadedFile) 
{ 
    var path = 
Path.Combine(env.WebRootPath,"Files",uploadedFile.FileName); 
    using (var stream = new FileStream(path, FileMode.Create)) 
    { 
        await uploadedFile.CopyToAsync(stream); 
    }; 
    return RedirectToAction("Index"); 
} 
 
Пример сохранения файла в байтовый массив «byte[] AvatarImage»: 
byte[] AvatarImage = new byte[(int)uploadedFile.Length]; 
await uploadedFile 
.OpenReadStream() 
.ReadAsync(AvatarImage, 0, (int)uploadedFile.Length); 
2.2.  Передача файлов клиенту методом контроллера 
Для отправки клиенту файлов предназначен абстрактный класс 
FileResult, который реализуется в классах: 
-  FileContentResult: отправляет клиенту массив байтов, считанный 
из файла; 
-  VirtualFileResult:  представляет  простую  отправку  файла 
напрямую с сервера по виртуальному пути; 
-  FileStreamResult:  создает  поток  -  объект  System.IO.Stream,  с 
помощью которого считывает и отправляет файл клиенту; 
-  PhysicalFileResult:  для  отправки  используется  реальный 
физический путь; 
Пример отправки файла «Picture.jpg» из папки «wwwroot/images»: 
public IActionResult GetImage([FromServices] IWebHostEnvironment env) 
{ 
  var provider = env.WebRootFileProvider;             
  var path = Path.Combine("images", "Picture1.jpg"); 
  var fInfo = provider.GetFileInfo(path); 
  var ext = Path.GetExtension(fInfo.Name); 
  var extProvider = new FileExtensionContentTypeProvider();   
  return File(fInfo.CreateReadStream(), 
         extProvider.Mappings[ext]); 
} 
 
3.  Выполнение работы 
3.1.  Исходные данные 
Используйте проект из лабораторной работы №3. 
3.2.  Задание №1 
Добавьте в проект возможность загрузки аватара пользователя. 
Изображение аватара должно храниться в базе данных. 
Выполните миграцию базы данных. 
3.2.1. Рекомендации к заданию №1 
Для хранения изображение в классе ApplicationUser добавьте свойство 
типа byte[]. Также можно добавить свойство, описывающее MIME-тип 
изображения. 
Для  получения  MIME-типа  изображения  можно  воспользоваться 
классом FileExtensionContentTypeProvider:  
 
var extProvider = new FileExtensionContentTypeProvider(); 
var MimeType = extProvider.Mappings[".png"]; 
3.3.  Задание №2 
На панели навигации, в меню пользователя должен отображаться 
аватар, сохраненный при регистрации пользователя. Если аватар отсутствует, 
то должен выводиться общий аватар из папки «wwwroot/images» 
3.3.1. Рекомендации к заданию 2 
Для передачи изображения создайте контроллер, метод GetAvatar() 
которого будет передавать аватар клиенту, а при его отсутствии – файл из 
папки «images». Для получения данных пользователя понадобится внедрить в 
контроллер класс UserManager, а для доступа к папке wwwroot – объект 
IHostingEnvironment. 
Для получения изображения в разметке в качестве значения атрибута 
src тэга img нужно указать адрес «Имя контроллера/GetImage». Для 
получения адреса воспользуйтесь вспомогательным методом @Url.Action. 
Изображение общего аватара поместите в папку wwwroot/Images. 
3.4.  Задание 3. 
Выберите любую предметную область.  
Требуется вывести на страницу список объектов выбранной 
передметной области с возможностью фильтрации по категориям. 
4.  Выполнение задания №3 
Примеры реализации смотрите в конце методички 
4.1.  Описание классов предметной области 
Добавьте в решение новый проект – библиотеку классов. Имя проекта 
XXX.Domain, где XXX – имя вашего решения. 
В созданном проекте создайте папку Entities. 
Для одной сущности из выбранной предметной области в папке Entities 
проекта создайте класс, содержащий следующие свойства: 
-  ID – уникальный номер; 
-  Название – короткое название конкретного объекта; 
-  Описание – дополнительное описание конкретного объекта; 
-  Категория – свойство для объединения объектов в группы; 
-  Цена/Вес/Расстояние  –  выберите  любой  параметр,  который  можно  в 
дальнейшем обработать математически, например, просуммировать; 
-  Изображение – путь к файлу изображения объекта 
В той же папке создайте класс, описывающий категорию объекта. 
Примечание: в классе Category свойство NormalizedName – это имя 
на английском языке, в нотации «kebab», которое будет использоваться как 
часть маршрута для фильтрации по категориям. Tак адрес запроса будет 
более понятным, по сравнению с передачей Id выбранной категории 
 
Примечание: здесь и далее используется предметная область – меню 
кафе. Сущностные классы – блюдо и категория блюда (Первые блюда, 
салаты, напитки и т.д.) 
 
Примечание: свойство Image и навигационное свойство Category в 
классе Dish описаны как nullable. 
В проекте XXX.UI сделайте ссылку на созданную библиотеку классов 
В файл _ViewImports.cshtml подключите пространство имен 
@using XXX.Domain.Entities 
4.2.  Вспомогательные классы 
В проект XXX.Domain добавьте папку Models 
Данные контроллером будут получаться с помощью сервисов. 
В папке Models опишите вспомогательные классы: 
ResponseData – класс, описывающий формат данных, получаемых от 
сервисов: 
public class ResponseData<T> 
{ 
    // запрашиваемые данные 
    public T Data { get; set; } 
    // признак успешного завершения запроса 
    public bool Success { get; set; } = true; 
    // сообщение в случае неуспешного завершения 
    public string? ErrorMessage { get; set; } 
} 
ProductListModel – класс, описывающий данные, используемые при 
получении и выводе на страницу списка объектов: 
public class ListModel<T> 
{ 
    // запрошенный список объектов 
    public List<T> Items { get; set; } = new(); 
    // номер текущей страницы 
    public int CurrentPage {  get; set; } = 1; 
    // общее количество страниц 
    public int TotalPages { get; set; } = 1; 
} 
Свойства CurrentPage и TotalPages понадобятся при разбиении общего 
списка на страницы 
4.3.  Описание сервисов 
В проект XXX.UI добавьте папку Services 
Методы сервисов должны возвращать объекты класса ResponseData. 
В папке Services создайте интерфейс ICategoryService (имя интерфейса 
выберите в зависимости от выбранной вами предметной области), который 
описывает метод получения списка всех категорий: 
public interface ICategoryService 
{ 
 /// <summary> 
 /// Получение списка всех категорий 
 /// </summary> 
 /// <returns></returns> 
 public Task<ResponseData<List<Category>>> GetCategoryListAsync(); 
} 
В папке Services опишите класс MemoryCetegoryService, реализующий 
интерфейс ICategoryService. Это сервис, имитирующий работу с реальными 
данными. Метод GetCategoryListAsync должен вернуть коллекцию 
объектов класса Category: 
public class MemoryCategoryService : ICategoryService 
{      
    public Task<ResponseData<List<Category>>> 
GetCategoryListAsync() 
    { 
        var categories = new List<Category> 
        { 
            new Category {Id=1, Name="Стартеры", 
   NormalizedName="starters"}, 
            new Category {Id=2, Name="Салаты", 
NormalizedName="salads"}, 
            . . . 
        }; 
        var result = new ResponseData<List<Category>>(); 
        result.Data=categories; 
        return Task.FromResult(result); 
    } 
} 
 
Зарегистрируйте сервис ICategoryService как scoped сервис в классе 
Program. 
 
В папке Services создайте интерфейс IProductService (имя интерфейса 
выберите в зависимости от выбранной вами предметной области), который 
описывает функции, необходимые для работы приложения: 
public interface IProductService 
{ 
    /// <summary> 
    /// Получение списка всех объектов 
    /// </summary> 
    /// <param name="categoryNormalizedName">нормализованное имя категории для 
фильтрации</param> 
    /// <param name="pageNo">номер страницы списка</param> 
    /// <returns></returns> 
    public Task<ResponseData<ListModel<Dish>>> GetProductListAsync(string? 
categoryNormalizedName, int pageNo=1); 
 
    /// <summary> 
    /// Поиск объекта по Id 
    /// </summary> 
    /// <param name="id">Идентификатор объекта</param> 
    /// <returns>Найденный объект или null, если объект не найден</returns> 
    public Task<ResponseData<Dish>> GetProductByIdAsync(int id); 
 
    /// <summary> 
    /// Обновление объекта 
    /// </summary> 
    /// <param name="id">Id изменяемомго объекта</param> 
    /// <param name="product">объект с новыми параметрами</param> 
    /// <param name="formFile">Файл изображения</param> 
    /// <returns></returns> 
    public Task UpdateProductAsync(int id, Dish product, IFormFile? formFile); 
    /// <summary> 
    /// Удаление объекта 
    /// </summary> 
    /// <param name="id">Id удаляемомго объекта</param> 
    /// <returns></returns> 
    public Task DeleteProductAsync(int id); 
    /// <summary> 
    /// Создание объекта 
    /// </summary> 
    /// <param name="product">Новый объект</param> 
    /// <param name="formFile">Файл изображения</param> 
    /// <returns>Созданный объект</returns> 
    public Task<ResponseData<Dish>> CreateProductAsync(Dish product, IFormFile? 
formFile); 
} 
В папке Services опишите класс MemoryProductService, реализующий 
интерфейс IProductService. Это сервис, имитирующий работу с реальными 
данными. На данном этапе достаточно реализовать метод: 
  GetProductListAsync 
Данные нужно описать в коде класса MemoryProductService в виде 
коллекций. В конструкторе класса нужно заполнить коллекции данными. Для 
установления связи с объектами класса Category внедрите объект 
ICategoryService. 
Примечание 1: В коллекции должно быть не менее 4 объектов. 
Примечание 2: Для правильной работы приложения поместите в папку 
wwwroot/Images файлы изображений объектов коллекции. 
Пример заполнения коллекции данными и реализации метода 
GetProductListAsync: 
public class MemoryProductService : IProductService 
{ 
    List<Dish> _dishes; 
    List<Category> _categories; 
 
    public MemoryProductService(ICategoryService categoryService) 
        { 
            _categories=categoryService.GetCategoryListAsync() 
.Result 
.Data; 
            SetupData(); 
        } 
. . . 
 
/// <summary> 
/// Инициализация списков 
/// </summary> 
private void SetupData() 
{  
_dishes = new List<Dish> 
            { 
                new Dish {Id = 1, Name="Суп-харчо", 
                    Description="Очень острый, невкусный", 
                    Calories =200, Image="Images/Суп.jpg",  
                    CategoryId= 
_categories.Find(c=>c.NormalizedName.Equals("soups")).Id}, 
                new Dish { Id = 2, Name="Борщ", 
                    Description="Много сала, без сметаны", 
                    Calories =330, Image="Images/Борщ.jpg", 
                    CategoryId= 
_categories.Find(c=>c.NormalizedName.Equals("soups")).Id}, 
 
  .  .  . 
                 
            }; 
} 
 
public Task<ResponseData<ProductListModel<Dish>>> 
GetProductListAsync( 
string? categoryNormalizedName,  
int pageNo = 1) 
{ 
    var model = new ProductListModel<Dish>() { Items=_dishes }; 
    var result = new ResponseData<ProductListModel<Dish>>() 
	 { 
        Data = model 
    }; 
    return Task.FromResult(result); 
} 
 
Зарегистрируйте сервис IProductService как scoped сервис в классе 
Program. 
4.4.  Вывод списка объектов на страницу приложения 
В папку Controllers добавьте контроллер Product (имя класса – 
ProductController). 
Внедрите в конструктор контроллера объекты типа IProductService и 
ICategoryService. 
В методе Index передайте представлению список объектов, например: 
public async Task<IActionResult> Index() 
{             
       var productResponse =  
await _service.GetProductListAsync(category); 
       if(!productResponse.Success) 
                return NotFound(productResponse.ErrorMessage);             
       return View(productResponse.Data.Items);             
} 
Добавьте представление Index для метода Index контроллера Product. 
Используйте шаблон «List». В качестве модели укажите объект вашей 
предметной области. 
В VS Code или VisualStudio for MAC для генерирования представлений 
необходимо: 
a)  Установить Code generation tool: 
dotnet tool install -g dotnet-aspnet-codegenerator 
b)  Установить в проект NuGet пакет 
dotnet add package Microsoft.VisualStudio.Web.CodeGeneration.Design 
 
Использование dotnet-aspnet-codegenerator описано здесь: 
https://learn.microsoft.com/en-us/aspnet/core/fundamentals/tools/dotnet-
aspnet-codegenerator?view=aspnetcore-6.0 
Пример создания страницы по шаблону Edit: 
 
dotnet-aspnet-codegenerator view MyEdit Edit -m Movie -dc MovieContext 
-outDir Views/Movies 
В полученном представлении замените вывод имени файла 
изображения на вывод самого изображения: 
<img src="@item.Image"/> 
Запустите проект. Перейдите на страницу «Каталог». Убедитесь, 
что страница отображается правильно, и текущий пункт меню 
выделен:
На основе вашего задания я помогу реализовать функциональность для работы с файлами и передачи данных в представление. Давайте разберем по шагам:

1. Сначала создадим необходимые модели
Models/Dish.cs
csharp
using System.ComponentModel.DataAnnotations;

namespace LabUI.Models
{
    public class Dish
    {
        public int Id { get; set; }
        
        [Required]
        public string Name { get; set; } = string.Empty;
        
        public string? Description { get; set; }
        
        [Range(0.01, double.MaxValue)]
        public decimal Price { get; set; }
        
        public string? Image { get; set; }
        
        public int CategoryId { get; set; }
        public Category? Category { get; set; }
    }
}
Models/Category.cs
csharp
namespace LabUI.Models
{
    public class Category
    {
        public int Id { get; set; }
        public string Name { get; set; } = string.Empty;
        public string NormalizedName { get; set; } = string.Empty;
    }
}
Models/ListModel.cs
csharp
namespace LabUI.Models
{
    public class ListModel<T>
    {
        public List<T> Items { get; set; } = new List<T>();
        public int CurrentPage { get; set; } = 1;
        public int TotalPages { get; set; } = 1;
        public int TotalCount { get; set; }
    }
}
Models/ResponseData.cs
csharp
namespace LabUI.Models
{
    public class ResponseData<T>
    {
        public T? Data { get; set; }
        public bool Success { get; set; } = true;
        public string? ErrorMessage { get; set; }
    }
}
2. Реализуем сервисы
Services/ICategoryService.cs
csharp
using LabUI.Models;

namespace LabUI.Services
{
    public interface ICategoryService
    {
        Task<ResponseData<List<Category>>> GetCategoryListAsync();
    }
}
Services/MemoryCategoryService.cs
csharp
using LabUI.Models;

namespace LabUI.Services
{
    public class MemoryCategoryService : ICategoryService
    {
        public Task<ResponseData<List<Category>>> GetCategoryListAsync()
        {
            var categories = new List<Category>
            {
                new Category { Id = 1, Name = "Стартеры", NormalizedName = "starters" },
                new Category { Id = 2, Name = "Салаты", NormalizedName = "salads" },
                new Category { Id = 3, Name = "Основные блюда", NormalizedName = "main-courses" },
                new Category { Id = 4, Name = "Десерты", NormalizedName = "desserts" },
                new Category { Id = 5, Name = "Напитки", NormalizedName = "drinks" }
            };

            var result = new ResponseData<List<Category>>
            {
                Data = categories
            };

            return Task.FromResult(result);
        }
    }
}
Services/IProductService.cs
csharp
using LabUI.Models;
using Microsoft.AspNetCore.Http;

namespace LabUI.Services
{
    public interface IProductService
    {
        Task<ResponseData<ListModel<Dish>>> GetProductListAsync(string? categoryNormalizedName, int pageNo = 1);
        Task<ResponseData<Dish>> GetProductByIdAsync(int id);
        Task UpdateProductAsync(int id, Dish product, IFormFile? formFile);
        Task DeleteProductAsync(int id);
        Task<ResponseData<Dish>> CreateProductAsync(Dish product, IFormFile? formFile);
    }
}
Services/MemoryProductService.cs
csharp
using LabUI.Models;
using Microsoft.AspNetCore.Http;

namespace LabUI.Services
{
    public class MemoryProductService : IProductService
    {
        private List<Dish> _dishes;
        private List<Category> _categories;

        public MemoryProductService(ICategoryService categoryService)
        {
            var categoryResponse = categoryService.GetCategoryListAsync().Result;
            _categories = categoryResponse.Data ?? new List<Category>();
            SetupData();
        }

        private void SetupData()
        {
            _dishes = new List<Dish>
            {
                new Dish 
                { 
                    Id = 1, 
                    Name = "Суп-харчо", 
                    Description = "Очень острый, невкусный", 
                    Price = 15.99m, 
                    Image = "Images/soup.jpg",  
                    CategoryId = _categories.Find(c => c.NormalizedName == "starters")?.Id ?? 1
                },
                new Dish 
                { 
                    Id = 2, 
                    Name = "Борщ", 
                    Description = "Много сала, без сметаны", 
                    Price = 12.50m, 
                    Image = "Images/borshch.jpg", 
                    CategoryId = _categories.Find(c => c.NormalizedName == "starters")?.Id ?? 1
                },
                new Dish 
                { 
                    Id = 3, 
                    Name = "Цезарь", 
                    Description = "С курицей и пармезаном", 
                    Price = 18.75m, 
                    Image = "Images/caesar.jpg", 
                    CategoryId = _categories.Find(c => c.NormalizedName == "salads")?.Id ?? 2
                },
                new Dish 
                { 
                    Id = 4, 
                    Name = "Стейк", 
                    Description = "Говяжий стейк средней прожарки", 
                    Price = 35.00m, 
                    Image = "Images/steak.jpg", 
                    CategoryId = _categories.Find(c => c.NormalizedName == "main-courses")?.Id ?? 3
                }
            };
        }

        public Task<ResponseData<ListModel<Dish>>> GetProductListAsync(string? categoryNormalizedName, int pageNo = 1)
        {
            var filteredDishes = _dishes;

            if (!string.IsNullOrEmpty(categoryNormalizedName))
            {
                var category = _categories.Find(c => c.NormalizedName == categoryNormalizedName);
                if (category != null)
                {
                    filteredDishes = _dishes.Where(d => d.CategoryId == category.Id).ToList();
                }
            }

            var model = new ListModel<Dish>
            {
                Items = filteredDishes,
                CurrentPage = pageNo,
                TotalPages = 1,
                TotalCount = filteredDishes.Count
            };

            var result = new ResponseData<ListModel<Dish>>
            {
                Data = model
            };

            return Task.FromResult(result);
        }

        public Task<ResponseData<Dish>> GetProductByIdAsync(int id)
        {
            var dish = _dishes.FirstOrDefault(d => d.Id == id);
            var result = new ResponseData<Dish>
            {
                Data = dish,
                Success = dish != null,
                ErrorMessage = dish == null ? "Блюдо не найдено" : null
            };

            return Task.FromResult(result);
        }

        public Task UpdateProductAsync(int id, Dish product, IFormFile? formFile)
        {
            var existingDish = _dishes.FirstOrDefault(d => d.Id == id);
            if (existingDish != null)
            {
                existingDish.Name = product.Name;
                existingDish.Description = product.Description;
                existingDish.Price = product.Price;
                existingDish.CategoryId = product.CategoryId;
            }
            return Task.CompletedTask;
        }

        public Task DeleteProductAsync(int id)
        {
            var dish = _dishes.FirstOrDefault(d => d.Id == id);
            if (dish != null)
            {
                _dishes.Remove(dish);
            }
            return Task.CompletedTask;
        }

        public Task<ResponseData<Dish>> CreateProductAsync(Dish product, IFormFile? formFile)
        {
            product.Id = _dishes.Max(d => d.Id) + 1;
            _dishes.Add(product);

            var result = new ResponseData<Dish>
            {
                Data = product
            };

            return Task.FromResult(result);
        }
    }
}
3. Контроллер для продуктов
Controllers/ProductController.cs
csharp
using LabUI.Services;
using Microsoft.AspNetCore.Mvc;

namespace LabUI.Controllers
{
    public class ProductController : Controller
    {
        private readonly IProductService _productService;
        private readonly ICategoryService _categoryService;

        public ProductController(IProductService productService, ICategoryService categoryService)
        {
            _productService = productService;
            _categoryService = categoryService;
        }

        public async Task<IActionResult> Index(string? category, int pageNo = 1)
        {
            var productResponse = await _productService.GetProductListAsync(category, pageNo);
            if (!productResponse.Success)
                return NotFound(productResponse.ErrorMessage);

            ViewBag.Categories = await _categoryService.GetCategoryListAsync();
            ViewBag.CurrentCategory = category;

            return View(productResponse.Data?.Items ?? new List<LabUI.Models.Dish>());
        }

        public async Task<IActionResult> Details(int id)
        {
            var productResponse = await _productService.GetProductByIdAsync(id);
            if (!productResponse.Success || productResponse.Data == null)
                return NotFound();

            return View(productResponse.Data);
        }
    }
}
4. Регистрация сервисов в Program.cs
csharp
using LabUI.Services;

var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
builder.Services.AddControllersWithViews();
builder.Services.AddScoped<ICategoryService, MemoryCategoryService>();
builder.Services.AddScoped<IProductService, MemoryProductService>();

var app = builder.Build();

// Configure the HTTP request pipeline.
if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Home/Error");
    app.UseHsts();
}

app.UseHttpsRedirection();
app.UseStaticFiles(); // Важно для работы со статическими файлами

app.UseRouting();
app.UseAuthorization();

app.MapControllerRoute(
    name: "default",
    pattern: "{controller=Home}/{action=Index}/{id?}");

app.Run();
5. Представление для списка продуктов
Views/Product/Index.cshtml
html
@model List<LabUI.Models.Dish>
@using LabUI.Services
@inject ICategoryService CategoryService

@{
    ViewData["Title"] = "Каталог блюд";
    var categoriesResponse = await CategoryService.GetCategoryListAsync();
    var categories = categoriesResponse.Data ?? new List<LabUI.Models.Category>();
    var currentCategory = ViewBag.CurrentCategory as string;
}

<div class="container">
    <h1>Каталог блюд</h1>

    <!-- Фильтр по категориям -->
    <div class="mb-4">
        <div class="btn-group">
            <a class="btn btn-outline-primary @(string.IsNullOrEmpty(currentCategory) ? "active" : "")" 
               asp-action="Index">Все</a>
            @foreach (var category in categories)
            {
                <a class="btn btn-outline-primary @(currentCategory == category.NormalizedName ? "active" : "")" 
                   asp-action="Index" asp-route-category="@category.NormalizedName">
                    @category.Name
                </a>
            }
        </div>
    </div>

    <!-- Список блюд -->
    <div class="row">
        @foreach (var dish in Model)
        {
            <div class="col-md-4 mb-4">
                <div class="card h-100">
                    @if (!string.IsNullOrEmpty(dish.Image))
                    {
                        <img src="~/@dish.Image" class="card-img-top" alt="@dish.Name" style="height: 200px; object-fit: cover;">
                    }
                    else
                    {
                        <img src="~/Images/default.jpg" class="card-img-top" alt="Нет изображения" style="height: 200px; object-fit: cover;">
                    }
                    <div class="card-body">
                        <h5 class="card-title">@dish.Name</h5>
                        <p class="card-text">@dish.Description</p>
                        <p class="card-text"><strong>Цена: @dish.Price.ToString("C")</strong></p>
                    </div>
                    <div class="card-footer">
                        <a asp-action="Details" asp-route-id="@dish.Id" class="btn btn-primary">Подробнее</a>
                    </div>
                </div>
            </div>
        }
    </div>
</div>
6. Навигационное меню
Добавьте в _Layout.cshtml пункт меню для каталога:

html
<li class="nav-item">
    <a class="nav-link text-dark" asp-controller="Product" asp-action="Index">Каталог</a>
</li>
7. Создайте папку для изображений
Создайте папку wwwroot/Images и добавьте туда изображения блюд с именами, соответствующими указанным в сервисе.

Этот код реализует:

Работу со статическими файлами (изображениями)

Передачу данных в представления

Фильтрацию по категориям

Сервисы для работы с данными

Основные CRUD-операции

Запустите проект и перейдите по адресу /Product чтобы увидеть каталог блюд.

namespace LabUI.Models
{
    public class ListModel<T>
    {
        public List<T> Items { get; set; } = new List<T>();
        public int CurrentPage { get; set; } = 1;
        public int TotalPages { get; set; } = 1;
        public int TotalCount { get; set; }
    }
}
ошибка
Severity	Code	Description	Project	File	Line	Suppression State	Details
Error (active)	CS0101	The namespace 'LabUI.Models' already contains a definition for 'ListModel'	LabUI	C:\Users\Alex\Desktop\BSUIR\WT\Labs4\LabUI\Models\ListModel.cs	3
Ошибка указывает, что класс ListModel уже определен в пространстве имен LabUI.Models. У вас есть несколько вариантов решения:

Вариант 1: Удалить дублирующий файл
Найдите и удалите второй файл ListModel.cs, который создает конфликт. Проверьте папку Models на наличие дублирующих файлов.

Вариант 2: Переименовать класс
Если вам нужны два разных класса с похожей функциональностью, переименуйте один из них:

Models/ProductListModel.cs
csharp
namespace LabUI.Models
{
    public class ProductListModel<T>
    {
        public List<T> Items { get; set; } = new List<T>();
        public int CurrentPage { get; set; } = 1;
        public int TotalPages { get; set; } = 1;
        public int TotalCount { get; set; }
    }
}
Вариант 3: Объединить функциональность в одном классе
Используйте один класс ListModel и обновите интерфейсы и сервисы:

Models/ListModel.cs (единая версия)
csharp
namespace LabUI.Models
{
    public class ListModel<T>
    {
        public List<T> Items { get; set; } = new List<T>();
        public int CurrentPage { get; set; } = 1;
        public int TotalPages { get; set; } = 1;
        public int TotalCount { get; set; }
    }
}
Обновите интерфейс IProductService
csharp
using LabUI.Models;
using Microsoft.AspNetCore.Http;

namespace LabUI.Services
{
    public interface IProductService
    {
        Task<ResponseData<ListModel<Dish>>> GetProductListAsync(string? categoryNormalizedName, int pageNo = 1);
        Task<ResponseData<Dish>> GetProductByIdAsync(int id);
        Task UpdateProductAsync(int id, Dish product, IFormFile? formFile);
        Task DeleteProductAsync(int id);
        Task<ResponseData<Dish>> CreateProductAsync(Dish product, IFormFile? formFile);
    }
}
Обновите MemoryProductService
csharp
using LabUI.Models;
using Microsoft.AspNetCore.Http;

namespace LabUI.Services
{
    public class MemoryProductService : IProductService
    {
        private List<Dish> _dishes;
        private List<Category> _categories;

        public MemoryProductService(ICategoryService categoryService)
        {
            var categoryResponse = categoryService.GetCategoryListAsync().Result;
            _categories = categoryResponse.Data ?? new List<Category>();
            SetupData();
        }

        private void SetupData()
        {
            _dishes = new List<Dish>
            {
                new Dish 
                { 
                    Id = 1, 
                    Name = "Суп-харчо", 
                    Description = "Очень острый, невкусный", 
                    Price = 15.99m, 
                    Image = "Images/soup.jpg",  
                    CategoryId = _categories.Find(c => c.NormalizedName == "starters")?.Id ?? 1
                },
                // ... остальные блюда
            };
        }

        public Task<ResponseData<ListModel<Dish>>> GetProductListAsync(string? categoryNormalizedName, int pageNo = 1)
        {
            var filteredDishes = _dishes;

            if (!string.IsNullOrEmpty(categoryNormalizedName))
            {
                var category = _categories.Find(c => c.NormalizedName == categoryNormalizedName);
                if (category != null)
                {
                    filteredDishes = _dishes.Where(d => d.CategoryId == category.Id).ToList();
                }
            }

            var model = new ListModel<Dish>
            {
                Items = filteredDishes,
                CurrentPage = pageNo,
                TotalPages = 1,
                TotalCount = filteredDishes.Count
            };

            var result = new ResponseData<ListModel<Dish>>
            {
                Data = model
            };

            return Task.FromResult(result);
        }

        // ... остальные методы
    }
}
Вариант 4: Проверить частичные классы
Если у вас есть partial class, убедитесь, что они правильно объявлены:

Models/ListModel.partial1.cs
csharp
namespace LabUI.Models
{
    public partial class ListModel<T>
    {
        public List<T> Items { get; set; } = new List<T>();
        public int CurrentPage { get; set; } = 1;
    }
}
Models/ListModel.partial2.cs
csharp
namespace LabUI.Models
{
    public partial class ListModel<T>
    {
        public int TotalPages { get; set; } = 1;
        public int TotalCount { get; set; }
    }
}
Рекомендуемое решение
Самый простой вариант - найти и удалить дублирующий файл ListModel.cs. Обычно эта ошибка возникает когда:

Вы создали класс дважды

Скопировали файл в проект

Используете шаблоны, которые автоматически создают классы

Проверьте:

Папку Models на наличие двух файлов с именем ListModel

Не используете ли вы partial class без ключевого слова partial

Нет ли класса ListModel в других папках проекта

После устранения конфликта проект должен компилироваться без ошибок.

using LabUI.Models;
using Microsoft.AspNetCore.Http;

namespace LabUI.Services
{
    public class MemoryProductService : IProductService
    {
        private List<Dish> _dishes;
        private List<Category> _categories;

        public MemoryProductService(ICategoryService categoryService)
        {
            var categoryResponse = categoryService.GetCategoryListAsync().Result;
            _categories = categoryResponse.Data ?? new List<Category>();
            SetupData();
        }

        private void SetupData()
        {
            _dishes = new List<Dish>
            {
                new Dish 
                { 
                    Id = 1, 
                    Name = "Суп-харчо", 
                    Description = "Очень острый, невкусный", 
                    Price = 15.99m, 
                    Image = "Images/soup.jpg",  
                    CategoryId = _categories.Find(c => c.NormalizedName == "starters")?.Id ?? 1
                },
                new Dish 
                { 
                    Id = 2, 
                    Name = "Борщ", 
                    Description = "Много сала, без сметаны", 
                    Price = 12.50m, 
                    Image = "Images/borshch.jpg", 
                    CategoryId = _categories.Find(c => c.NormalizedName == "starters")?.Id ?? 1
                },
                new Dish 
                { 
                    Id = 3, 
                    Name = "Цезарь", 
                    Description = "С курицей и пармезаном", 
                    Price = 18.75m, 
                    Image = "Images/caesar.jpg", 
                    CategoryId = _categories.Find(c => c.NormalizedName == "salads")?.Id ?? 2
                },
                new Dish 
                { 
                    Id = 4, 
                    Name = "Стейк", 
                    Description = "Говяжий стейк средней прожарки", 
                    Price = 35.00m, 
                    Image = "Images/steak.jpg", 
                    CategoryId = _categories.Find(c => c.NormalizedName == "main-courses")?.Id ?? 3
                }
            };
        }

        public Task<ResponseData<ListModel<Dish>>> GetProductListAsync(string? categoryNormalizedName, int pageNo = 1)
        {
            var filteredDishes = _dishes;

            if (!string.IsNullOrEmpty(categoryNormalizedName))
            {
                var category = _categories.Find(c => c.NormalizedName == categoryNormalizedName);
                if (category != null)
                {
                    filteredDishes = _dishes.Where(d => d.CategoryId == category.Id).ToList();
                }
            }

            var model = new ListModel<Dish>
            {
                Items = filteredDishes,
                CurrentPage = pageNo,
                TotalPages = 1,
                TotalCount = filteredDishes.Count
            };

            var result = new ResponseData<ListModel<Dish>>
            {
                Data = model
            };

            return Task.FromResult(result);
        }

        public Task<ResponseData<Dish>> GetProductByIdAsync(int id)
        {
            var dish = _dishes.FirstOrDefault(d => d.Id == id);
            var result = new ResponseData<Dish>
            {
                Data = dish,
                Success = dish != null,
                ErrorMessage = dish == null ? "Блюдо не найдено" : null
            };

            return Task.FromResult(result);
        }

        public Task UpdateProductAsync(int id, Dish product, IFormFile? formFile)
        {
            var existingDish = _dishes.FirstOrDefault(d => d.Id == id);
            if (existingDish != null)
            {
                existingDish.Name = product.Name;
                existingDish.Description = product.Description;
                existingDish.Price = product.Price;
                existingDish.CategoryId = product.CategoryId;
            }
            return Task.CompletedTask;
        }

        public Task DeleteProductAsync(int id)
        {
            var dish = _dishes.FirstOrDefault(d => d.Id == id);
            if (dish != null)
            {
                _dishes.Remove(dish);
            }
            return Task.CompletedTask;
        }

        public Task<ResponseData<Dish>> CreateProductAsync(Dish product, IFormFile? formFile)
        {
            product.Id = _dishes.Max(d => d.Id) + 1;
            _dishes.Add(product);

            var result = new ResponseData<Dish>
            {
                Data = product
            };

            return Task.FromResult(result);
        }
    }
}
как  поменять валюту
Чтобы изменить отображение валюты в вашем приложении, нужно изменить форматирование цены. Вот несколько способов:

1. Изменение в представлении (рекомендуемый способ)
В файле Views/Product/Index.cshtml замените:
html
<p class="card-text"><strong>Цена: @dish.Price.ToString("C")</strong></p>
На один из вариантов:

html
<!-- Белорусские рубли -->
<p class="card-text"><strong>Цена: @dish.Price.ToString("C") руб.</strong></p>

<!-- Или с кастомным форматированием -->
<p class="card-text"><strong>Цена: @dish.Price.ToString("N2") руб.</strong></p>

<!-- Или просто число -->
<p class="card-text"><strong>Цена: @dish.Price руб.</strong></p>
2. Создание вспомогательного метода
Создайте класс-хелпер:
csharp
// Helpers/PriceHelper.cs
namespace LabUI.Helpers
{
    public static class PriceHelper
    {
        public static string FormatPrice(decimal price)
        {
            return $"{price:N2} руб.";
        }
        
        public static string FormatPrice(decimal price, string currency)
        {
            return $"{price:N2} {currency}";
        }
    }
}
Добавьте using в представление и используйте:
html
@using LabUI.Helpers

<p class="card-text"><strong>Цена: @PriceHelper.FormatPrice(dish.Price)</strong></p>
3. Изменение культуры приложения
В Program.cs добавьте:
csharp
using System.Globalization;

var builder = WebApplication.CreateBuilder(args);

// Установка культуры для русского языка и белорусских рублей
var cultureInfo = new CultureInfo("ru-RU");
cultureInfo.NumberFormat.CurrencySymbol = "руб.";
CultureInfo.DefaultThreadCurrentCulture = cultureInfo;
CultureInfo.DefaultThreadCurrentUICulture = cultureInfo;

// Добавьте сервисы
builder.Services.AddControllersWithViews();
builder.Services.AddScoped<ICategoryService, MemoryCategoryService>();
builder.Services.AddScoped<IProductService, MemoryProductService>();

var app = builder.Build();
// ... остальной код
4. Создание DisplayTemplate
Создайте папку Views/Shared/DisplayTemplates и файл Decimal.cshtml:
html
@model decimal
@{
    var formattedPrice = $"{Model:N2} руб.";
}
@formattedPrice
Используйте в представлении:
html
<p class="card-text"><strong>Цена: @Html.DisplayFor(m => dish.Price)</strong></p>
5. Добавление свойства форматированной цены в модель
В классе Dish добавьте свойство:
csharp
public class Dish
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string? Description { get; set; }
    public decimal Price { get; set; }
    public string? Image { get; set; }
    public int CategoryId { get; set; }
    public Category? Category { get; set; }
    
    // Добавьте это свойство
    public string FormattedPrice => $"{Price:N2} руб.";
}
Используйте в представлении:
html
<p class="card-text"><strong>Цена: @dish.FormattedPrice</strong></p>
6. Полный пример обновленного представления
html
@model List<LabUI.Models.Dish>
@using LabUI.Services
@inject ICategoryService CategoryService

@{
    ViewData["Title"] = "Каталог блюд";
    var categoriesResponse = await CategoryService.GetCategoryListAsync();
    var categories = categoriesResponse.Data ?? new List<LabUI.Models.Category>();
    var currentCategory = ViewBag.CurrentCategory as string;
}

<div class="container">
    <h1>Каталог блюд</h1>

    <!-- Фильтр по категориям -->
    <div class="mb-4">
        <div class="btn-group">
            <a class="btn btn-outline-primary @(string.IsNullOrEmpty(currentCategory) ? "active" : "")" 
               asp-action="Index">Все</a>
            @foreach (var category in categories)
            {
                <a class="btn btn-outline-primary @(currentCategory == category.NormalizedName ? "active" : "")" 
                   asp-action="Index" asp-route-category="@category.NormalizedName">
                    @category.Name
                </a>
            }
        </div>
    </div>

    <!-- Список блюд -->
    <div class="row">
        @foreach (var dish in Model)
        {
            <div class="col-md-4 mb-4">
                <div class="card h-100">
                    @if (!string.IsNullOrEmpty(dish.Image))
                    {
                        <img src="~/@dish.Image" class="card-img-top" alt="@dish.Name" style="height: 200px; object-fit: cover;">
                    }
                    else
                    {
                        <img src="~/Images/default.jpg" class="card-img-top" alt="Нет изображения" style="height: 200px; object-fit: cover;">
                    }
                    <div class="card-body">
                        <h5 class="card-title">@dish.Name</h5>
                        <p class="card-text">@dish.Description</p>
                        <!-- Измененная строка с ценой -->
                        <p class="card-text"><strong>Цена: @dish.Price.ToString("N2") руб.</strong></p>
                    </div>
                    <div class="card-footer">
                        <a asp-action="Details" asp-route-id="@dish.Id" class="btn btn-primary">Подробнее</a>
                    </div>
                </div>
            </div>
        }
    </div>
</div>
Рекомендую использовать вариант 1 или 5 - они самые простые и понятные. Вариант с изменением строки формата в представлении (@dish.Price.ToString("N2") руб.) наиболее гибкий и не требует изменения моделей или конфигурации приложения.

Переделай по новым вводным

Передача данных представлению. Передача файлов. 
 
1.  Цель работы. 
Дальнейшее изучение механизма передачи данных представлению. 
Изучение работы с файлами в ASP.NET Core. 
 
2.  Общие сведения. 
2.1.  Работа со статическими файлами 
Статические файлы, такие как HTML, CSS, изображения и JavaScript, 
приложение ASP.NET Core может предоставлять непосредственно клиенту. 
Статические файлы как правило располагаются по пути Web Root: 
    <content-root>/wwwroot 
В качестве Content-root обычно выбирается папка, в которой 
размещены все файлы проекта 
Возможность работы со статическими файлами задается в Program: 
app.UseStaticFiles(); 
 
Пример доступа к файлу <content-root>/wwwroot/css/site.css: 
<link asp-href-include="/css/site.css" rel="stylesheet" /> 
 
Для работы с файлами в ASP.NET Core используются поставщики 
файлов (file providers). 
Поставщики файлов - это абстракция над файловыми системами. 
Основным интерфейсом является IFileProvider.  
IFileProvider предоставляет методы для получения информации о 
файлах (IFileInfo), информации о каталоге (IDirectoryContents) и настройке 
уведомлений об изменениях (с использованием IChangeToken). 
IFileInfo предоставляет методы и свойства отдельных файлов или 
каталогов. Он имеет два булевых свойства: Exists и IsDirectory, а также 
свойства, описывающие имя файла, длину (в байтах) и дату LastModified.  
Читать из файла можно с помощью метода CreateReadStream. 
Конкретной реализации интерфейса IFileProvider является 
PhysicalFileProvider, который обеспечивает доступ к физической файловой 
системе. Он обертывает тип System.IO.File (для физического поставщика), 
просматривая все пути к каталогу и его дочерним элементам. Это 
ограничивает доступ только к определенному каталогу и его дочерним 
элементам, предотвращая доступ к файловой системе за пределами этой 
границы. 
Готовые провайдеры для Content_Root и Web_Root можно получить из 
объекта IWebHostEnvironment: 
public HomeController(IWebHostEnvironment env) 
{ 
    var webRootFileProvider = env.WebRootFileProvider; 
    var conentRootFileProvider = env.ContentRootFileProvider; 
}; 
2.1.  Передача файлов на сервер 
Чтобы поддерживать загрузку файлов, HTML-форма должна иметь 
атрибут  
    enctype="multipart/form-data" 
Доступ к отдельным файлам, загруженным на сервер, можно получить 
через привязку модели с использованием интерфейса IFormFile. 
Интерфейс IFormFile описывает следующие методы и свойства: 
public interface IFormFile 
{ 
  string ContentType { get; } 
  string ContentDisposition { get; } 
  IHeaderDictionary Headers { get; } 
  long Length { get; } 
  string Name { get; } 
 string FileName { get; } 
  Stream OpenReadStream(); 
  void CopyTo(Stream target); 
  Task CopyToAsync(Stream target,   
CancellationToken cancellationToken = null); 
} 
Пример сохранения файла в папке «wwwroot/Files»: 
[HttpPost] 
public async Task<IActionResult> Upload( 
                [FromServices] IWebHostEnvironment env, 
                [FromForm] IFormFile uploadedFile) 
{ 
    var path = 
Path.Combine(env.WebRootPath,"Files",uploadedFile.FileName); 
    using (var stream = new FileStream(path, FileMode.Create)) 
    { 
        await uploadedFile.CopyToAsync(stream); 
    }; 
    return RedirectToAction("Index"); 
} 
 
Пример сохранения файла в байтовый массив «byte[] AvatarImage»: 
byte[] AvatarImage = new byte[(int)uploadedFile.Length]; 
await uploadedFile 
.OpenReadStream() 
.ReadAsync(AvatarImage, 0, (int)uploadedFile.Length); 
2.2.  Передача файлов клиенту методом контроллера 
Для отправки клиенту файлов предназначен абстрактный класс 
FileResult, который реализуется в классах: 
-  FileContentResult: отправляет клиенту массив байтов, считанный 
из файла; 
-  VirtualFileResult:  представляет  простую  отправку  файла 
напрямую с сервера по виртуальному пути; 
-  FileStreamResult:  создает  поток  -  объект  System.IO.Stream,  с 
помощью которого считывает и отправляет файл клиенту; 
-  PhysicalFileResult:  для  отправки  используется  реальный 
физический путь; 
Пример отправки файла «Picture.jpg» из папки «wwwroot/images»: 
public IActionResult GetImage([FromServices] IWebHostEnvironment env) 
{ 
  var provider = env.WebRootFileProvider;             
  var path = Path.Combine("images", "Picture1.jpg"); 
  var fInfo = provider.GetFileInfo(path); 
  var ext = Path.GetExtension(fInfo.Name); 
  var extProvider = new FileExtensionContentTypeProvider();   
  return File(fInfo.CreateReadStream(), 
         extProvider.Mappings[ext]); 
} 
 
3.  Выполнение работы 
3.1.  Исходные данные 
Используйте проект из лабораторной работы №3. 
3.2.  Задание №1 
Добавьте в проект возможность загрузки аватара пользователя. 
Изображение аватара должно храниться в базе данных. 
Выполните миграцию базы данных. 
3.2.1. Рекомендации к заданию №1 
Для хранения изображение в классе ApplicationUser добавьте свойство 
типа byte[]. Также можно добавить свойство, описывающее MIME-тип 
изображения. 
Для  получения  MIME-типа  изображения  можно  воспользоваться 
классом FileExtensionContentTypeProvider:  
 
var extProvider = new FileExtensionContentTypeProvider(); 
var MimeType = extProvider.Mappings[".png"]; 
3.3.  Задание №2 
На панели навигации, в меню пользователя должен отображаться 
аватар, сохраненный при регистрации пользователя. Если аватар отсутствует, 
то должен выводиться общий аватар из папки «wwwroot/images» 
3.3.1. Рекомендации к заданию 2 
Для передачи изображения создайте контроллер, метод GetAvatar() 
которого будет передавать аватар клиенту, а при его отсутствии – файл из 
папки «images». Для получения данных пользователя понадобится внедрить в 
контроллер класс UserManager, а для доступа к папке wwwroot – объект 
IHostingEnvironment. 
Для получения изображения в разметке в качестве значения атрибута 
src тэга img нужно указать адрес «Имя контроллера/GetImage». Для 
получения адреса воспользуйтесь вспомогательным методом @Url.Action. 
Изображение общего аватара поместите в папку wwwroot/Images. 
3.4.  Задание 3. 
Выберите любую предметную область.  
Требуется вывести на страницу список объектов выбранной 
передметной области с возможностью фильтрации по категориям. 
4.  Выполнение задания №3 
Примеры реализации смотрите в конце методички 
4.1.  Описание классов предметной области 
Добавьте в решение новый проект – библиотеку классов. Имя проекта 
XXX.Domain, где XXX – имя вашего решения. 
В созданном проекте создайте папку Entities. 
Для одной сущности из выбранной предметной области в папке Entities 
проекта создайте класс, содержащий следующие свойства: 
-  ID – уникальный номер; 
-  Название – короткое название конкретного объекта; 
-  Описание – дополнительное описание конкретного объекта; 
-  Категория – свойство для объединения объектов в группы; 
-  Цена/Вес/Расстояние  –  выберите  любой  параметр,  который  можно  в 
дальнейшем обработать математически, например, просуммировать; 
-  Изображение – путь к файлу изображения объекта 
В той же папке создайте класс, описывающий категорию объекта. 
Примечание: в классе Category свойство NormalizedName – это имя 
на английском языке, в нотации «kebab», которое будет использоваться как 
часть маршрута для фильтрации по категориям. Tак адрес запроса будет 
более понятным, по сравнению с передачей Id выбранной категории 
 
Примечание: здесь и далее используется предметная область – меню 
кафе. Сущностные классы – блюдо и категория блюда (Первые блюда, 
салаты, напитки и т.д.) 
 
Примечание: свойство Image и навигационное свойство Category в 
классе Dish описаны как nullable. 
В проекте XXX.UI сделайте ссылку на созданную библиотеку классов 
В файл _ViewImports.cshtml подключите пространство имен 
@using XXX.Domain.Entities 
4.2.  Вспомогательные классы 
В проект XXX.Domain добавьте папку Models 
Данные контроллером будут получаться с помощью сервисов. 
В папке Models опишите вспомогательные классы: 
ResponseData – класс, описывающий формат данных, получаемых от 
сервисов: 
public class ResponseData<T> 
{ 
    // запрашиваемые данные 
    public T Data { get; set; } 
    // признак успешного завершения запроса 
    public bool Success { get; set; } = true; 
    // сообщение в случае неуспешного завершения 
    public string? ErrorMessage { get; set; } 
} 
ProductListModel – класс, описывающий данные, используемые при 
получении и выводе на страницу списка объектов: 
public class ListModel<T> 
{ 
    // запрошенный список объектов 
    public List<T> Items { get; set; } = new(); 
    // номер текущей страницы 
    public int CurrentPage {  get; set; } = 1; 
    // общее количество страниц 
    public int TotalPages { get; set; } = 1; 
} 
Свойства CurrentPage и TotalPages понадобятся при разбиении общего 
списка на страницы 
4.3.  Описание сервисов 
В проект XXX.UI добавьте папку Services 
Методы сервисов должны возвращать объекты класса ResponseData. 
В папке Services создайте интерфейс ICategoryService (имя интерфейса 
выберите в зависимости от выбранной вами предметной области), который 
описывает метод получения списка всех категорий: 
public interface ICategoryService 
{ 
 /// <summary> 
 /// Получение списка всех категорий 
 /// </summary> 
 /// <returns></returns> 
 public Task<ResponseData<List<Category>>> GetCategoryListAsync(); 
} 
В папке Services опишите класс MemoryCetegoryService, реализующий 
интерфейс ICategoryService. Это сервис, имитирующий работу с реальными 
данными. Метод GetCategoryListAsync должен вернуть коллекцию 
объектов класса Category: 
public class MemoryCategoryService : ICategoryService 
{      
    public Task<ResponseData<List<Category>>> 
GetCategoryListAsync() 
    { 
        var categories = new List<Category> 
        { 
            new Category {Id=1, Name="Стартеры", 
   NormalizedName="starters"}, 
            new Category {Id=2, Name="Салаты", 
NormalizedName="salads"}, 
            . . . 
        }; 
        var result = new ResponseData<List<Category>>(); 
        result.Data=categories; 
        return Task.FromResult(result); 
    } 
} 
 
Зарегистрируйте сервис ICategoryService как scoped сервис в классе 
Program. 
 
В папке Services создайте интерфейс IProductService (имя интерфейса 
выберите в зависимости от выбранной вами предметной области), который 
описывает функции, необходимые для работы приложения: 
public interface IProductService 
{ 
    /// <summary> 
    /// Получение списка всех объектов 
    /// </summary> 
    /// <param name="categoryNormalizedName">нормализованное имя категории для 
фильтрации</param> 
    /// <param name="pageNo">номер страницы списка</param> 
    /// <returns></returns> 
    public Task<ResponseData<ListModel<Dish>>> GetProductListAsync(string? 
categoryNormalizedName, int pageNo=1); 
 
    /// <summary> 
    /// Поиск объекта по Id 
    /// </summary> 
    /// <param name="id">Идентификатор объекта</param> 
    /// <returns>Найденный объект или null, если объект не найден</returns> 
    public Task<ResponseData<Dish>> GetProductByIdAsync(int id); 
 
    /// <summary> 
    /// Обновление объекта 
    /// </summary> 
    /// <param name="id">Id изменяемомго объекта</param> 
    /// <param name="product">объект с новыми параметрами</param> 
    /// <param name="formFile">Файл изображения</param> 
    /// <returns></returns> 
    public Task UpdateProductAsync(int id, Dish product, IFormFile? formFile); 
    /// <summary> 
    /// Удаление объекта 
    /// </summary> 
    /// <param name="id">Id удаляемомго объекта</param> 
    /// <returns></returns> 
    public Task DeleteProductAsync(int id); 
    /// <summary> 
    /// Создание объекта 
    /// </summary> 
    /// <param name="product">Новый объект</param> 
    /// <param name="formFile">Файл изображения</param> 
    /// <returns>Созданный объект</returns> 
    public Task<ResponseData<Dish>> CreateProductAsync(Dish product, IFormFile? 
formFile); 
} 
В папке Services опишите класс MemoryProductService, реализующий 
интерфейс IProductService. Это сервис, имитирующий работу с реальными 
данными. На данном этапе достаточно реализовать метод: 
  GetProductListAsync 
Данные нужно описать в коде класса MemoryProductService в виде 
коллекций. В конструкторе класса нужно заполнить коллекции данными. Для 
установления связи с объектами класса Category внедрите объект 
ICategoryService. 
Примечание 1: В коллекции должно быть не менее 4 объектов. 
Примечание 2: Для правильной работы приложения поместите в папку 
wwwroot/Images файлы изображений объектов коллекции. 
Пример заполнения коллекции данными и реализации метода 
GetProductListAsync: 
public class MemoryProductService : IProductService 
{ 
    List<Dish> _dishes; 
    List<Category> _categories; 
 
    public MemoryProductService(ICategoryService categoryService) 
        { 
            _categories=categoryService.GetCategoryListAsync() 
.Result 
.Data; 
            SetupData(); 
        } 
. . . 
 
/// <summary> 
/// Инициализация списков 
/// </summary> 
private void SetupData() 
{  
_dishes = new List<Dish> 
            { 
                new Dish {Id = 1, Name="Суп-харчо", 
                    Description="Очень острый, невкусный", 
                    Calories =200, Image="Images/Суп.jpg",  
                    CategoryId= 
_categories.Find(c=>c.NormalizedName.Equals("soups")).Id}, 
                new Dish { Id = 2, Name="Борщ", 
                    Description="Много сала, без сметаны", 
                    Calories =330, Image="Images/Борщ.jpg", 
                    CategoryId= 
_categories.Find(c=>c.NormalizedName.Equals("soups")).Id}, 
 
  .  .  . 
                 
            }; 
} 
 
public Task<ResponseData<ProductListModel<Dish>>> 
GetProductListAsync( 
string? categoryNormalizedName,  
int pageNo = 1) 
{ 
    var model = new ProductListModel<Dish>() { Items=_dishes }; 
    var result = new ResponseData<ProductListModel<Dish>>() 
	 { 
        Data = model 
    }; 
    return Task.FromResult(result); 
} 
 
Зарегистрируйте сервис IProductService как scoped сервис в классе 
Program. 
4.4.  Вывод списка объектов на страницу приложения 
В папку Controllers добавьте контроллер Product (имя класса – 
ProductController). 
Внедрите в конструктор контроллера объекты типа IProductService и 
ICategoryService. 
В методе Index передайте представлению список объектов, например: 
public async Task<IActionResult> Index() 
{             
       var productResponse =  
await _service.GetProductListAsync(category); 
       if(!productResponse.Success) 
                return NotFound(productResponse.ErrorMessage);             
       return View(productResponse.Data.Items);             
} 
Добавьте представление Index для метода Index контроллера Product. 
Используйте шаблон «List». В качестве модели укажите объект вашей 
предметной области. 
В VS Code или VisualStudio for MAC для генерирования представлений 
необходимо: 
a)  Установить Code generation tool: 
dotnet tool install -g dotnet-aspnet-codegenerator 
b)  Установить в проект NuGet пакет 
dotnet add package Microsoft.VisualStudio.Web.CodeGeneration.Design 
 
Использование dotnet-aspnet-codegenerator описано здесь: 
https://learn.microsoft.com/en-us/aspnet/core/fundamentals/tools/dotnet-
aspnet-codegenerator?view=aspnetcore-6.0 
Пример создания страницы по шаблону Edit: 
 
dotnet-aspnet-codegenerator view MyEdit Edit -m Movie -dc MovieContext 
-outDir Views/Movies 
В полученном представлении замените вывод имени файла 
изображения на вывод самого изображения: 
<img src="@item.Image"/> 
Запустите проект. Перейдите на страницу «Каталог». Убедитесь, 
что страница отображается правильно, и текущий пункт меню 
выделен: 
4.5.  Оформление списка объектов 
Требуется оформить список объектов в виде карт (см. 
https://getbootstrap.com/docs/5.1/components/card/#using-grid-markup ), по 3 
карты в одном ряду. 
Один элемент списка должен содержать: 
  изображение объекта 
  название объекта (Card title) 
  описание объекта 
  кнопку «Добавить в корзину» 
Кнопка «Добавить в корзину» должна передавать управление методу 
Add контроллера Cart (будут добавлены в дальнейшем). Также должны 
передаваться Id выбранного элемента и параметр returnurl – адрес текущей 
страницы для возврата к списку после добавления в корзину. 
Адрес текущей страницы можно получить так: 
var request = ViewContext.HttpContext.Request; 
var returnUrl = request.Path + request.QueryString.ToUriComponent(); 
Примечание: для того, чтобы карты имели одинаковый размер, необходимо, 
чтобы изображения объектов имели одинаковые соотношения сторон. 
Убедитесь, что при наведении курсора на кнопку добавления в корзину 
указывается правильный адрес: 
4.6.  Добавление фильтра по категориям 
Требуется предоставить возможность выбора объектов по категориям. 
Выбор представить в виде выпадающего списка, который можно оформить в 
виде компонента Bootstrap Dropdown 
(https://getbootstrap.com/docs/5.1/components/dropdowns/#single-button )  
или копонента Nav-item  Dropdown 
(https://getbootstrap.com/docs/5.1/components/navs-tabs/#tabs-with-dropdowns ) 
При выборе категории в контроллер должен передаваться 
NormalizedName выбранной категории. В списке категорий должно 
выводится название текущей категории. 
4.6.1. Рекомендации к заданию 4.6 
Измените метод Index контроллера Product: 
public async Task<IActionResult> Index(string? category) 
 
Для оформления списка категорий в методе Index контроллера Product 
нужно: 
  получить список категорий; 
  получить имя текущей категории; 
  передать полученные данные в представление с помощью ViewData 
или ViewBag. 
Пример разметки для выбора категории: 
<!-- выбор категории --> 
<div class="col-2 border-2"> 
    <ul class="nav "> 
        <li class="nav-item dropdown"> 
            <a class="nav-link dropdown-toggle"  
data-bs-toggle="dropdown"  
href="#" 
               role="button"  
aria-expanded="false">@ViewData["currentCategory"] 
  </a> 
            <ul class="dropdown-menu"> 
                <li> 
                    <a class="dropdown-item" 
                           asp-controller="product" 
                           asp-route-category=@null>Все</a> 
                </li> 
                @foreach (var item in categories) 
                { 
                    <li> 
                      <a class="dropdown-item" 
                        asp-controller="product" 
                        asp-route-category="@item.NormalizedName"> 
@item.Name 
  </a> 
                    </li> 
                } 
            </ul> 
        </li> 
    </ul> 
</div><!-- выбор категории --> 
В классе MemoryProductService, в методе GetProductListAsync 
выполните фильтрацию объектов по категории: 
var data = _dishes 
      .Where(d => categoryNormalizedName == null || 
    d.Category.NormalizedName.Equals(categoryNormalizedName)) 
 .ToList(); 
Запустите проект, проверьте результат 
 
 
 
6.  Пример выполнения работы 

6.2.  Добавление аватара пользователя 
6.2.1. Изменение класса ApplicationUser 
-  Добавьте  класс  ApplicationUser  свойства,  описывающие  данные 
аватара и его Mime тип: 
-   
public class ApplicationUser : IdentityUser 
{ 
    public byte[]? Avatar { get; set; } 
    public string MimeType { get; set; } = string.Empty; 
} 
-  Выполнте миграцию базы данных 

-   
-  Выполните команду «update-database» 
-   
-  Убедитесь, что в таблице AspNetUsers появились новые поля. 
-   
6.2.2. Изменение страницы Register 
В коде страницы внесите следующие изменения. 
Добавьте в класс InputModel свойство: 
public IFormFile Avatar { get; set; } 
Измените метод OnPostAsync для сохранения изображения в базе 
данных: 
var user = CreateUser(); 
 
await _userStore.SetUserNameAsync(user, Input.Email, 
CancellationToken.None); 
await _emailStore.SetEmailAsync(user, Input.Email, 
CancellationToken.None); 
 
if(Input.Avatar!=null) 
{ 
    user.Avatar = new byte[Input.Avatar.Length]; 
    await Input.Avatar 
        .OpenReadStream() 
        .ReadAsync(user.Avatar); 
    var extProvider = new FileExtensionContentTypeProvider(); 
    var ext = Path.GetExtension(Input.Avatar.FileName); 
    user.MimeType = extProvider.Mappings[ext]; 
}           
 
var result = await _userManager.CreateAsync(user, Input.Password); 
-  Измените  страницу  Register,  чтобы  пользователь  при  регистрации 
мог указать файл аватарки и отослать его на сервер: 
 
<form asp-route-returnUrl="@Model.ReturnUrl"  
method="post"  
enctype="multipart/form-data"> 
<h4>Create a new account.</h4> 
            . . .  
<div class="mb-3"> 
    <label asp-for="Input.Avatar" class="form-label"> 
Avatar</label> 
    <input asp-for="Input.Avatar" class="form-control" /> 
</div> 
 
<button type="submit"  
class="btn btn-primary">Register</button> 
</form> 
 
Зарегистрируйте пользователя с аватаром. Убедитесь, что данные 
сохраняются в базе данных. 
6.3.  Отображение аватара пользователя 
6.3.1. Создание контроллера 
В папке Controllers проекта создайте контроллер Image. Опишите метод 
GetAvatar(), который вернет изображение клиенту: 
public class ImageController(UserManager<ApplicationUser> 
userManager) : Controller 
{ 
    public async Task<IActionResult> GetAvatar() 
    { 
        var email = User.FindFirst(ClaimTypes.Email)!.Value; 
        var user = await userManager.FindByEmailAsync(email); 
        if (user == null) 
        { 
            return NotFound(); 
        } 
        if (user.Avatar != null) 
            return File(user.Avatar, user.MimeType); 
 
        var imagePath = Path.Combine("Images", "default-profile-
picture.png"); 
  return File(imagePath,"image/png"); 
    } 
} 
6.3.2. Изменение представления _UserInfoPartial 
<div class="dropdown ml-4 nav-color"> 
        <div class="dropdown-toggle"  
id="dropdownMenuButton"  
data-toggle="dropdown" aria-haspopup="true"  
aria-expanded="false"> 
            <img src="@Url.Action("GetAvatar","Image")"  
width="30" alt="User"  
class="rounded bg-light" /> 
        </div> 
        <div class="dropdown-menu"  
aria-labelledby="dropdownMenuButton"> 
            <div class="dropdown-item-text"> 
                <img src="@Url.Action("GetAvatar","Image")"  
width="50" alt="User" class="rounded" /> 
                @User.Identity.Name 
            </div> 
 
Запустите проект.

6.4.  Создание классов предметной области 
ВНИМАНИЕ: 
В предлагаемом примере используется предметная область – кафе. 
Сущность предметной области – Dish (блюдо) и Category (категория блюда). 
Для выполнения задания добавьте в папку «wwwroot/images» 
несколько изображений объектов вашей предметной области. Для удобства 
отображения желательно, чтобы изображения были одного размера или, хотя 
бы, имели одинаковое соотношение сторон. 
Классы предметной области поместите в папку Entities проекта 
XXX.Domain 
Пример класса Dish: 

public class Dish 
{ 
    public int Id { get; set; } // id блюда 
    public string Name { get; set; } // название блюда 
    public string Description { get; set; } // описание блюда 
    public int Calories { get; set; } // кол. калорий на порцию 
    public string? Image { get; set; } // путь к файлу изображения    
 
    // Навигационные свойства 
    /// <summary> 
    /// группа блюд (например, супы, напитки и т.д.) 
    /// </summary> 
    public int CategoryId { get; set; } 
    [JsonIgnore] 
    public Category? Category { get; set; } 
} 
Пример класса Category: 
public class Category 
{ 
    public int Id { get; set; } 
    public string Name { get; set; } 
    public string NormalizedName { get; set; } 
} 
6.5.  Вывод списка объектов на страницу 
6.5.1. Создание контроллера 
В папке Controllers основного проекта создайте пустой контроллер 
Product (имя класса контроллера – ProductController). 
public class ProductController(ICategoryService categoryService, 
IProductService productService) : Controller 
{ 
    public async Task<IActionResult> Index() 
    { 
        var productResponse = 
                    await 
productService.GetProductListAsync(null); 
        if (!productResponse.Success) 
            return NotFound(productResponse.ErrorMessage); 
        return View(productResponse.Data.Items); 
    } 
} 
6.5.2. Создание представления с помощью scaffolding 
В представлении описана модель: 
@model IEnumerable<WebLabsV03.Domain.Entities.Dish> 
 
В файл _ViewImports добавьте: 
@using XXX.Domain.Entities 
Измените модель в представлении Index: 
@model IEnumerable<Dish> 
6.5.3. Пример оформления представления Index 
@model IEnumerable<WebLabsV03.Domain.Entities.Dish> 
 
@{ 
    ViewData["Title"] = "Index"; 
    var request = ViewContext.HttpContext.Request; 
    var returnUrl = request.Path + request.QueryString.ToUriComponent(); 
} 
 
<h2 class="m-3">Блюда дня</h2> 
<div class="card-group"> 
 
@foreach (var item in Model) 
{ 
    <div class="col-4 p-4"> 
        <div class="card border-dark m-2"> 
            <img class="card-img-top" src="@item.Image" alt="No image available" /> 
            <div class="card-body"> 
                <h5 class="card-title">@item.Name</h5> 
                <p class="card-text">@item.Description</p> 
   <h5><span class="badge bg-secondary">@item.Calories 
калорий</span></h5> 
            </div><!-- card-body --> 
            <div class="card-footer text-center"> 
                <a class="btn btn-outline-primary" 
                   asp-action="add" asp-controller="cart" 
                   asp-route-id="@item.Id" 
                   asp-route-returnurl="@returnUrl"> 
                    Add to cart <i class="fa-solid fa-cart-shopping"></i> 
                </a> 
            </div><!-- card-footer --> 
        </div><!-- card --> 
    </div> 
    <!-- col --> 
} 
</div> 
 
6.5.4. Пример реализации метода Index для фильтрации по категории 
public async Task<IActionResult> Index(string? category) 
{ 
    // получить список категорий 
    var categoriesResponse = await 
categoryService.GetCategoryListAsync(); 
 
    // если список не получен, вернуть код 404 
    if (!categoriesResponse.Success) 
        return NotFound(categoriesResponse.ErrorMessage); 
 
    // передать список категорий во ViewData        
    ViewData["categories"] = categoriesResponse.Data; 
 
    // передать во ViewData имя текущей категории 
    var currentCategory = category == null 
        ? "Все" 
        : categoriesResponse.Data.FirstOrDefault(c => 
c.NormalizedName == category)?.Name; 
    ViewData["currentCategory"] = currentCategory; 
 
 
    var productResponse = 
                await 
productService.GetProductListAsync(category); 
    if (!productResponse.Success) 
        ViewData["Error"]=productResponse.ErrorMessage; 
    return View(productResponse.Data.Items); 
} 
6.5.5. Пример фильтрации по категории в MemoryProductService 
public Task<ResponseData<ProductListModel<Dish>>> 
GetProductListAsync(string? categoryNormalizedName, int pageNo = 
1) 
{ 
 // Создать объект результата 
    var result = new ResponseData<ProductListModel<Dish>>(); 
    // Id категории для фильрации 
    int? categoryId=null; 
 
    // если требуется фильтрация, то найти Id категории 
    // с заданным categoryNormalizedName 
    if (categoryNormalizedName != null) 
        categoryId = _categories 
        .Find(c => 
c.NormalizedName.Equals(categoryNormalizedName)) 
         ?.Id; 
 
    // Выбрать объекты, отфильтрованные по Id категории, 
    // если этот Id имеется 
    var data = _dishes 
        .Where(d => categoryId == null || 
d.CategoryId.Equals(categoryId))? 
        .ToList(); 
             
    // поместить ранные в объект результата 
    result.Data = new ProductListModel<Dish>() { Items = data }; 
                 
    // Если список пустой 
    if(data.Count==0) 
    { 
        result.Success = false; 
        result.ErrorMessage = "Нет объектов в выбраннной 
категории"; 
    } 
    // Вернуть результат 
    return Task.FromResult(result); 
} 
6.5.6. Пример представления Index с выбором категории 
@model IEnumerable<Dish> 
 
@{ 
    ViewData["Title"] = "Index"; 
    var request = ViewContext.HttpContext.Request; 
    var returnUrl = request.Path + 
request.QueryString.ToUriComponent(); 
 
    var categories = ViewData["categories"] as 
IEnumerable<Category>; 
 } 
 
<h2 class="m-3">Блюда дня</h2> 
<div class="row"> 
    <!-- выбор категории --> 
 <div class="col-2 border-2"> 
        <ul class="nav "> 
            <li class="nav-item dropdown"> 
                <a class="nav-link dropdown-toggle" 
                   data-bs-toggle="dropdown" 
                   href="#" 
                   role="button" 
                   aria-expanded="false"> 
                    @ViewData["currentCategory"] 
                </a> 
                <ul class="dropdown-menu"> 
                    <li> 
                        <a class="dropdown-item" 
                           asp-controller="product" 
                           asp-route-category=@null>Все</a> 
                    </li> 
                    @foreach (var item in categories) 
                    { 
                        <li> 
                            <a class="dropdown-item" 
                               asp-controller="product" 
                               asp-route-
category="@item.NormalizedName"> 
                                @item.Name 
                            </a> 
                        </li> 
                    } 
                </ul> 
            </li> 
        </ul> 
     
</div> 
    @if (Model != null) 
    { 
        <div class="card-group"> 
 
            @foreach (var item in Model) 
            { 
                <div class="col-4 p-4"> 
                    <div class="card border-dark m-2"> 
                        <img class="card-img-top" 
src="@item.Image" alt="No image available" /> 
                        <div class="card-body"> 
                            <h5 class="card-title">@item.Name</h5> 
                            <p class="card-
text">@item.Description</p> 
                            <h5><span class="badge bg-
secondary">@item.Calories калорий</span></h5> 
                        </div><!-- card-body --> 
                        <div class="card-footer text-center"> 
                            <a class="btn btn-outline-primary" 
  asp-action="add" asp-controller="cart" 
                            asp-route-id="@item.Id" 
                            asp-route-returnurl="@returnUrl"> 
                                Add to cart <i class="fa-solid fa-
cart-shopping"></i> 
                            </a> 
                        </div><!-- card-footer --> 
                    </div><!-- card --> 
                </div> 
                <!-- col --> 
            } 
        </div> 
    }     
     
<h2 class="text-warning">@ViewData["Error"]</h2>
На основе новых вводных я переделаю проект с учетом всех требований. Давайте реализуем все задания по порядку:

1. Задание №1 - Добавление аватара пользователя
Models/ApplicationUser.cs
csharp
using Microsoft.AspNetCore.Identity;

namespace LabUI.Models
{
    public class ApplicationUser : IdentityUser
    {
        public byte[]? Avatar { get; set; }
        public string MimeType { get; set; } = string.Empty;
    }
}
Areas/Identity/Pages/Account/Register.cshtml.cs
csharp
using LabUI.Models;
using Microsoft.AspNetCore.Identity;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.RazorPages;
using Microsoft.AspNetCore.WebUtilities;
using System.ComponentModel.DataAnnotations;
using System.Text;

namespace LabUI.Areas.Identity.Pages.Account
{
    public class RegisterModel : PageModel
    {
        private readonly SignInManager<ApplicationUser> _signInManager;
        private readonly UserManager<ApplicationUser> _userManager;
        private readonly IUserStore<ApplicationUser> _userStore;
        private readonly IUserEmailStore<ApplicationUser> _emailStore;
        private readonly ILogger<RegisterModel> _logger;

        public RegisterModel(
            UserManager<ApplicationUser> userManager,
            IUserStore<ApplicationUser> userStore,
            SignInManager<ApplicationUser> signInManager,
            ILogger<RegisterModel> logger)
        {
            _userManager = userManager;
            _userStore = userManager;
            _emailStore = GetEmailStore();
            _signInManager = signInManager;
            _logger = logger;
        }

        [BindProperty]
        public InputModel Input { get; set; }

        public string ReturnUrl { get; set; }

        public class InputModel
        {
            [Required]
            [EmailAddress]
            [Display(Name = "Email")]
            public string Email { get; set; }

            [Required]
            [StringLength(100, ErrorMessage = "The {0} must be at least {2} and at max {1} characters long.", MinimumLength = 6)]
            [DataType(DataType.Password)]
            [Display(Name = "Password")]
            public string Password { get; set; }

            [DataType(DataType.Password)]
            [Display(Name = "Confirm password")]
            [Compare("Password", ErrorMessage = "The password and confirmation password do not match.")]
            public string ConfirmPassword { get; set; }

            public IFormFile Avatar { get; set; }
        }

        public async Task OnGetAsync(string returnUrl = null)
        {
            ReturnUrl = returnUrl;
        }

        public async Task<IActionResult> OnPostAsync(string returnUrl = null)
        {
            returnUrl ??= Url.Content("~/");
            
            if (ModelState.IsValid)
            {
                var user = CreateUser();

                await _userStore.SetUserNameAsync(user, Input.Email, CancellationToken.None);
                await _emailStore.SetEmailAsync(user, Input.Email, CancellationToken.None);

                // Обработка аватара
                if (Input.Avatar != null)
                {
                    user.Avatar = new byte[Input.Avatar.Length];
                    await Input.Avatar
                        .OpenReadStream()
                        .ReadAsync(user.Avatar);
                    
                    var extProvider = new Microsoft.AspNetCore.StaticFiles.FileExtensionContentTypeProvider();
                    var ext = Path.GetExtension(Input.Avatar.FileName);
                    if (extProvider.Mappings.ContainsKey(ext))
                    {
                        user.MimeType = extProvider.Mappings[ext];
                    }
                    else
                    {
                        user.MimeType = "image/png";
                    }
                }

                var result = await _userManager.CreateAsync(user, Input.Password);

                if (result.Succeeded)
                {
                    _logger.LogInformation("User created a new account with password.");

                    await _signInManager.SignInAsync(user, isPersistent: false);
                    return LocalRedirect(returnUrl);
                }
                foreach (var error in result.Errors)
                {
                    ModelState.AddModelError(string.Empty, error.Description);
                }
            }

            return Page();
        }

        private ApplicationUser CreateUser()
        {
            try
            {
                return Activator.CreateInstance<ApplicationUser>();
            }
            catch
            {
                throw new InvalidOperationException($"Can't create an instance of '{nameof(ApplicationUser)}'.");
            }
        }

        private IUserEmailStore<ApplicationUser> GetEmailStore()
        {
            if (!_userManager.SupportsUserEmail)
            {
                throw new NotSupportedException("The default UI requires a user store with email support.");
            }
            return (IUserEmailStore<ApplicationUser>)_userStore;
        }
    }
}
Areas/Identity/Pages/Account/Register.cshtml
html
@page
@model RegisterModel
@{
    ViewData["Title"] = "Register";
}

<h1>@ViewData["Title"]</h1>

<div class="row">
    <div class="col-md-4">
        <form asp-route-returnUrl="@Model.ReturnUrl" method="post" enctype="multipart/form-data">
            <h4>Create a new account.</h4>
            <hr />
            <div asp-validation-summary="All" class="text-danger"></div>
            <div class="form-group">
                <label asp-for="Input.Email"></label>
                <input asp-for="Input.Email" class="form-control" />
                <span asp-validation-for="Input.Email" class="text-danger"></span>
            </div>
            <div class="form-group">
                <label asp-for="Input.Password"></label>
                <input asp-for="Input.Password" class="form-control" />
                <span asp-validation-for="Input.Password" class="text-danger"></span>
            </div>
            <div class="form-group">
                <label asp-for="Input.ConfirmPassword"></label>
                <input asp-for="Input.ConfirmPassword" class="form-control" />
                <span asp-validation-for="Input.ConfirmPassword" class="text-danger"></span>
            </div>
            <div class="mb-3">
                <label asp-for="Input.Avatar" class="form-label">Avatar</label>
                <input asp-for="Input.Avatar" class="form-control" />
            </div>
            <button type="submit" class="btn btn-primary">Register</button>
        </form>
    </div>
</div>

@section Scripts {
    <partial name="_ValidationScriptsPartial" />
}
2. Задание №2 - Отображение аватара пользователя
Controllers/ImageController.cs
csharp
using LabUI.Models;
using Microsoft.AspNetCore.Identity;
using Microsoft.AspNetCore.Mvc;
using System.Security.Claims;

namespace LabUI.Controllers
{
    public class ImageController : Controller
    {
        private readonly UserManager<ApplicationUser> _userManager;
        private readonly IWebHostEnvironment _env;

        public ImageController(UserManager<ApplicationUser> userManager, IWebHostEnvironment env)
        {
            _userManager = userManager;
            _env = env;
        }

        public async Task<IActionResult> GetAvatar()
        {
            var userEmail = User.FindFirst(ClaimTypes.Email)?.Value;
            if (string.IsNullOrEmpty(userEmail))
            {
                return GetDefaultAvatar();
            }

            var user = await _userManager.FindByEmailAsync(userEmail);
            if (user == null)
            {
                return GetDefaultAvatar();
            }

            if (user.Avatar != null && user.Avatar.Length > 0)
            {
                return File(user.Avatar, user.MimeType);
            }

            return GetDefaultAvatar();
        }

        private IActionResult GetDefaultAvatar()
        {
            var imagePath = Path.Combine(_env.WebRootPath, "Images", "default-profile-picture.png");
            if (System.IO.File.Exists(imagePath))
            {
                return PhysicalFile(imagePath, "image/png");
            }
            
            // Если файл по умолчанию не найден, вернуть пустое изображение
            return NotFound();
        }
    }
}
Views/Shared/_LoginPartial.cshtml (обновленная версия)
html
@using Microsoft.AspNetCore.Identity
@using LabUI.Models
@inject SignInManager<ApplicationUser> SignInManager
@inject UserManager<ApplicationUser> UserManager

<ul class="navbar-nav">
@if (SignInManager.IsSignedIn(User))
{
    <li class="nav-item dropdown">
        <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
            <img src="@Url.Action("GetAvatar", "Image")" width="30" height="30" alt="User" class="rounded-circle" />
            @User.Identity?.Name
        </a>
        <ul class="dropdown-menu" aria-labelledby="navbarDropdown">
            <li>
                <div class="dropdown-item-text">
                    <img src="@Url.Action("GetAvatar", "Image")" width="50" height="50" alt="User" class="rounded-circle" />
                    @User.Identity?.Name
                </div>
            </li>
            <li><hr class="dropdown-divider"></li>
            <li>
                <form class="form-inline" asp-area="Identity" asp-page="/Account/Logout" asp-route-returnUrl="@Url.Action("Index", "Home", new { area = "" })">
                    <button type="submit" class="dropdown-item">Logout</button>
                </form>
            </li>
        </ul>
    </li>
}
else
{
    <li class="nav-item">
        <a class="nav-link text-dark" asp-area="Identity" asp-page="/Account/Register">Register</a>
    </li>
    <li class="nav-item">
        <a class="nav-link text-dark" asp-area="Identity" asp-page="/Account/Login">Login</a>
    </li>
}
</ul>
3. Задание №3 - Предметная область (Меню кафе)
Models/Dish.cs
csharp
using System.ComponentModel.DataAnnotations;
using System.Text.Json.Serialization;

namespace LabUI.Models
{
    public class Dish
    {
        public int Id { get; set; }
        
        [Required]
        public string Name { get; set; } = string.Empty;
        
        public string Description { get; set; } = string.Empty;
        
        [Range(1, int.MaxValue)]
        public int Calories { get; set; }
        
        public string? Image { get; set; }
        
        public int CategoryId { get; set; }
        
        [JsonIgnore]
        public Category? Category { get; set; }
    }
}
Models/Category.cs
csharp
namespace LabUI.Models
{
    public class Category
    {
        public int Id { get; set; }
        public string Name { get; set; } = string.Empty;
        public string NormalizedName { get; set; } = string.Empty;
    }
}
4. Сервисы для работы с данными
Services/ICategoryService.cs
csharp
using LabUI.Models;

namespace LabUI.Services
{
    public interface ICategoryService
    {
        Task<ResponseData<List<Category>>> GetCategoryListAsync();
    }
}
Services/MemoryCategoryService.cs
csharp
using LabUI.Models;

namespace LabUI.Services
{
    public class MemoryCategoryService : ICategoryService
    {
        public Task<ResponseData<List<Category>>> GetCategoryListAsync()
        {
            var categories = new List<Category>
            {
                new Category { Id = 1, Name = "Стартеры", NormalizedName = "starters" },
                new Category { Id = 2, Name = "Салаты", NormalizedName = "salads" },
                new Category { Id = 3, Name = "Основные блюда", NormalizedName = "main-courses" },
                new Category { Id = 4, Name = "Десерты", NormalizedName = "desserts" },
                new Category { Id = 5, Name = "Напитки", NormalizedName = "drinks" }
            };

            var result = new ResponseData<List<Category>>
            {
                Data = categories
            };

            return Task.FromResult(result);
        }
    }
}
Services/IProductService.cs
csharp
using LabUI.Models;
using Microsoft.AspNetCore.Http;

namespace LabUI.Services
{
    public interface IProductService
    {
        Task<ResponseData<ListModel<Dish>>> GetProductListAsync(string? categoryNormalizedName, int pageNo = 1);
        Task<ResponseData<Dish>> GetProductByIdAsync(int id);
        Task UpdateProductAsync(int id, Dish product, IFormFile? formFile);
        Task DeleteProductAsync(int id);
        Task<ResponseData<Dish>> CreateProductAsync(Dish product, IFormFile? formFile);
    }
}
Services/MemoryProductService.cs
csharp
using LabUI.Models;
using Microsoft.AspNetCore.Http;

namespace LabUI.Services
{
    public class MemoryProductService : IProductService
    {
        private List<Dish> _dishes;
        private List<Category> _categories;

        public MemoryProductService(ICategoryService categoryService)
        {
            var categoryResponse = categoryService.GetCategoryListAsync().Result;
            _categories = categoryResponse.Data ?? new List<Category>();
            SetupData();
        }

        private void SetupData()
        {
            _dishes = new List<Dish>
            {
                new Dish 
                { 
                    Id = 1, 
                    Name = "Суп-харчо", 
                    Description = "Очень острый, невкусный", 
                    Calories = 200, 
                    Image = "Images/soup.jpg",  
                    CategoryId = _categories.Find(c => c.NormalizedName == "starters")?.Id ?? 1
                },
                new Dish 
                { 
                    Id = 2, 
                    Name = "Борщ", 
                    Description = "Много сала, без сметаны", 
                    Calories = 330, 
                    Image = "Images/borshch.jpg", 
                    CategoryId = _categories.Find(c => c.NormalizedName == "starters")?.Id ?? 1
                },
                new Dish 
                { 
                    Id = 3, 
                    Name = "Цезарь", 
                    Description = "С курицей и пармезаном", 
                    Calories = 180, 
                    Image = "Images/caesar.jpg", 
                    CategoryId = _categories.Find(c => c.NormalizedName == "salads")?.Id ?? 2
                },
                new Dish 
                { 
                    Id = 4, 
                    Name = "Стейк", 
                    Description = "Говяжий стейк средней прожарки", 
                    Calories = 450, 
                    Image = "Images/steak.jpg", 
                    CategoryId = _categories.Find(c => c.NormalizedName == "main-courses")?.Id ?? 3
                },
                new Dish 
                { 
                    Id = 5, 
                    Name = "Тирамису", 
                    Description = "Итальянский десерт", 
                    Calories = 320, 
                    Image = "Images/tiramisu.jpg", 
                    CategoryId = _categories.Find(c => c.NormalizedName == "desserts")?.Id ?? 4
                },
                new Dish 
                { 
                    Id = 6, 
                    Name = "Кофе", 
                    Description = "Свежесваренный арабика", 
                    Calories = 5, 
                    Image = "Images/coffee.jpg", 
                    CategoryId = _categories.Find(c => c.NormalizedName == "drinks")?.Id ?? 5
                }
            };
        }

        public Task<ResponseData<ListModel<Dish>>> GetProductListAsync(string? categoryNormalizedName, int pageNo = 1)
        {
            int? categoryId = null;

            if (categoryNormalizedName != null)
            {
                categoryId = _categories.Find(c => c.NormalizedName.Equals(categoryNormalizedName))?.Id;
            }

            var data = _dishes.Where(d => categoryId == null || d.CategoryId.Equals(categoryId)).ToList();

            var model = new ListModel<Dish>
            {
                Items = data,
                CurrentPage = pageNo,
                TotalPages = 1,
                TotalCount = data.Count
            };

            var result = new ResponseData<ListModel<Dish>>
            {
                Data = model
            };

            if (data.Count == 0)
            {
                result.Success = false;
                result.ErrorMessage = "Нет объектов в выбранной категории";
            }

            return Task.FromResult(result);
        }

        public Task<ResponseData<Dish>> GetProductByIdAsync(int id)
        {
            var dish = _dishes.FirstOrDefault(d => d.Id == id);
            var result = new ResponseData<Dish>
            {
                Data = dish,
                Success = dish != null,
                ErrorMessage = dish == null ? "Блюдо не найдено" : null
            };

            return Task.FromResult(result);
        }

        public Task UpdateProductAsync(int id, Dish product, IFormFile? formFile)
        {
            var existingDish = _dishes.FirstOrDefault(d => d.Id == id);
            if (existingDish != null)
            {
                existingDish.Name = product.Name;
                existingDish.Description = product.Description;
                existingDish.Calories = product.Calories;
                existingDish.CategoryId = product.CategoryId;
            }
            return Task.CompletedTask;
        }

        public Task DeleteProductAsync(int id)
        {
            var dish = _dishes.FirstOrDefault(d => d.Id == id);
            if (dish != null)
            {
                _dishes.Remove(dish);
            }
            return Task.CompletedTask;
        }

        public Task<ResponseData<Dish>> CreateProductAsync(Dish product, IFormFile? formFile)
        {
            product.Id = _dishes.Max(d => d.Id) + 1;
            _dishes.Add(product);

            var result = new ResponseData<Dish>
            {
                Data = product
            };

            return Task.FromResult(result);
        }
    }
}
5. Контроллер Product
Controllers/ProductController.cs
csharp
using LabUI.Services;
using Microsoft.AspNetCore.Mvc;

namespace LabUI.Controllers
{
    public class ProductController : Controller
    {
        private readonly IProductService _productService;
        private readonly ICategoryService _categoryService;

        public ProductController(IProductService productService, ICategoryService categoryService)
        {
            _productService = productService;
            _categoryService = categoryService;
        }

        public async Task<IActionResult> Index(string? category)
        {
            var categoriesResponse = await _categoryService.GetCategoryListAsync();
            if (!categoriesResponse.Success)
                return NotFound(categoriesResponse.ErrorMessage);

            ViewData["categories"] = categoriesResponse.Data;

            var currentCategory = category == null 
                ? "Все" 
                : categoriesResponse.Data?.FirstOrDefault(c => c.NormalizedName == category)?.Name ?? "Все";
            ViewData["currentCategory"] = currentCategory;

            var productResponse = await _productService.GetProductListAsync(category);
            if (!productResponse.Success)
                ViewData["Error"] = productResponse.ErrorMessage;

            return View(productResponse.Data?.Items ?? new List<Models.Dish>());
        }

        public async Task<IActionResult> Details(int id)
        {
            var productResponse = await _productService.GetProductByIdAsync(id);
            if (!productResponse.Success || productResponse.Data == null)
                return NotFound();

            return View(productResponse.Data);
        }
    }
}
6. Представление Index для Product
Views/Product/Index.cshtml
html
@model IEnumerable<Dish>

@{
    ViewData["Title"] = "Каталог блюд";
    var request = ViewContext.HttpContext.Request;
    var returnUrl = request.Path + request.QueryString.ToUriComponent();
    var categories = ViewData["categories"] as IEnumerable<Category>;
}

<div class="container">
    <h1 class="m-3">Блюда дня</h1>
    
    <div class="row">
        <!-- выбор категории -->
        <div class="col-2 border-2">
            <ul class="nav">
                <li class="nav-item dropdown">
                    <a class="nav-link dropdown-toggle" data-bs-toggle="dropdown" href="#" role="button" aria-expanded="false">
                        @ViewData["currentCategory"]
                    </a>
                    <ul class="dropdown-menu">
                        <li>
                            <a class="dropdown-item" asp-controller="Product" asp-route-category=@null>Все</a>
                        </li>
                        @if (categories != null)
                        {
                            @foreach (var item in categories)
                            {
                                <li>
                                    <a class="dropdown-item" asp-controller="Product" asp-route-category="@item.NormalizedName">
                                        @item.Name
                                    </a>
                                </li>
                            }
                        }
                    </ul>
                </li>
            </ul>
        </div>

        @if (Model != null && Model.Any())
        {
            <div class="col-10">
                <div class="row">
                    @foreach (var item in Model)
                    {
                        <div class="col-md-4 mb-4">
                            <div class="card h-100 border-dark">
                                @if (!string.IsNullOrEmpty(item.Image))
                                {
                                    <img class="card-img-top" src="~/@item.Image" alt="@item.Name" style="height: 200px; object-fit: cover;">
                                }
                                else
                                {
                                    <img class="card-img-top" src="~/Images/default-dish.jpg" alt="No image" style="height: 200px; object-fit: cover;">
                                }
                                <div class="card-body">
                                    <h5 class="card-title">@item.Name</h5>
                                    <p class="card-text">@item.Description</p>
                                    <h5><span class="badge bg-secondary">@item.Calories калорий</span></h5>
                                </div>
                                <div class="card-footer text-center">
                                    <a class="btn btn-outline-primary" 
                                       asp-action="Add" 
                                       asp-controller="Cart" 
                                       asp-route-id="@item.Id" 
                                       asp-route-returnurl="@returnUrl">
                                        Добавить в корзину <i class="fas fa-cart-shopping"></i>
                                    </a>
                                </div>
                            </div>
                        </div>
                    }
                </div>
            </div>
        }
        else
        {
            <div class="col-10">
                <h2 class="text-warning">@ViewData["Error"]</h2>
            </div>
        }
    </div>
</div>
7. Регистрация сервисов в Program.cs
csharp
using LabUI.Services;
using Microsoft.AspNetCore.Identity;
using Microsoft.EntityFrameworkCore;
using LabUI.Models;

var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
var connectionString = builder.Configuration.GetConnectionString("DefaultConnection");
builder.Services.AddDbContext<ApplicationDbContext>(options =>
    options.UseSqlServer(connectionString));
builder.Services.AddDatabaseDeveloperPageExceptionFilter();

builder.Services.AddDefaultIdentity<ApplicationUser>(options => options.SignIn.RequireConfirmedAccount = true)
    .AddEntityFrameworkStores<ApplicationDbContext>();
builder.Services.AddControllersWithViews();

// Регистрация кастомных сервисов
builder.Services.AddScoped<ICategoryService, MemoryCategoryService>();
builder.Services.AddScoped<IProductService, MemoryProductService>();

var app = builder.Build();

// Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
{
    app.UseMigrationsEndPoint();
}
else
{
    app.UseExceptionHandler("/Home/Error");
    app.UseHsts();
}

app.UseHttpsRedirection();
app.UseStaticFiles(); // Важно для работы со статическими файлами

app.UseRouting();

app.UseAuthentication();
app.UseAuthorization();

app.MapControllerRoute(
    name: "default",
    pattern: "{controller=Home}/{action=Index}/{id?}");
app.MapRazorPages();

app.Run();
8. Миграция базы данных
Выполните в Package Manager Console:

bash
Add-Migration AddAvatarToUser
Update-Database
Что было реализовано:
✅ Задание №1 - Добавление аватара пользователя с сохранением в БД

✅ Задание №2 - Отображение аватара в навигационной панели

✅ Задание №3 - Предметная область "Меню кафе" с фильтрацией по категориям

✅ Карточное отображение блюд (по 3 в ряду)

✅ Выпадающий список категорий для фильтрации

✅ Кнопка "Добавить в корзину"

✅ Работа со статическими файлами (изображениями)

Проект готов к использованию и соответствует всем требованиям задания.

Avatar добавлен в "Data\AppUser.cs"
using Microsoft.AspNetCore.Identity;

namespace LabUI.Data
{
    public class AppUser: IdentityUser
    {
        public byte[] Avatar { get; set; }
    }
}
Отлично! Теперь нужно обновить код для работы с вашим классом AppUser. Вот исправленные файлы:

1. Обновление Register.cshtml.cs
Areas/Identity/Pages/Account/Register.cshtml.cs
csharp
using LabUI.Data;
using Microsoft.AspNetCore.Identity;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.RazorPages;
using System.ComponentModel.DataAnnotations;

namespace LabUI.Areas.Identity.Pages.Account
{
    public class RegisterModel : PageModel
    {
        private readonly SignInManager<AppUser> _signInManager;
        private readonly UserManager<AppUser> _userManager;
        private readonly IUserStore<AppUser> _userStore;
        private readonly ILogger<RegisterModel> _logger;

        public RegisterModel(
            UserManager<AppUser> userManager,
            IUserStore<AppUser> userStore,
            SignInManager<AppUser> signInManager,
            ILogger<RegisterModel> logger)
        {
            _userManager = userManager;
            _userStore = userStore;
            _signInManager = signInManager;
            _logger = logger;
        }

        [BindProperty]
        public InputModel Input { get; set; }

        public string ReturnUrl { get; set; }

        public class InputModel
        {
            [Required]
            [EmailAddress]
            [Display(Name = "Email")]
            public string Email { get; set; }

            [Required]
            [StringLength(100, ErrorMessage = "The {0} must be at least {2} and at max {1} characters long.", MinimumLength = 6)]
            [DataType(DataType.Password)]
            [Display(Name = "Password")]
            public string Password { get; set; }

            [DataType(DataType.Password)]
            [Display(Name = "Confirm password")]
            [Compare("Password", ErrorMessage = "The password and confirmation password do not match.")]
            public string ConfirmPassword { get; set; }

            public IFormFile Avatar { get; set; }
        }

        public async Task OnGetAsync(string returnUrl = null)
        {
            ReturnUrl = returnUrl;
        }

        public async Task<IActionResult> OnPostAsync(string returnUrl = null)
        {
            returnUrl ??= Url.Content("~/");
            
            if (ModelState.IsValid)
            {
                var user = CreateUser();

                await _userStore.SetUserNameAsync(user, Input.Email, CancellationToken.None);

                // Обработка аватара
                if (Input.Avatar != null && Input.Avatar.Length > 0)
                {
                    using (var memoryStream = new MemoryStream())
                    {
                        await Input.Avatar.CopyToAsync(memoryStream);
                        user.Avatar = memoryStream.ToArray();
                    }
                }

                var result = await _userManager.CreateAsync(user, Input.Password);

                if (result.Succeeded)
                {
                    _logger.LogInformation("User created a new account with password.");

                    await _signInManager.SignInAsync(user, isPersistent: false);
                    return LocalRedirect(returnUrl);
                }
                foreach (var error in result.Errors)
                {
                    ModelState.AddModelError(string.Empty, error.Description);
                }
            }

            return Page();
        }

        private AppUser CreateUser()
        {
            try
            {
                return Activator.CreateInstance<AppUser>();
            }
            catch
            {
                throw new InvalidOperationException($"Can't create an instance of '{nameof(AppUser)}'.");
            }
        }
    }
}
2. Обновление ImageController.cs
Controllers/ImageController.cs
csharp
using LabUI.Data;
using Microsoft.AspNetCore.Identity;
using Microsoft.AspNetCore.Mvc;
using System.Security.Claims;

namespace LabUI.Controllers
{
    public class ImageController : Controller
    {
        private readonly UserManager<AppUser> _userManager;
        private readonly IWebHostEnvironment _env;

        public ImageController(UserManager<AppUser> userManager, IWebHostEnvironment env)
        {
            _userManager = userManager;
            _env = env;
        }

        public async Task<IActionResult> GetAvatar()
        {
            var userEmail = User.FindFirst(ClaimTypes.Email)?.Value;
            if (string.IsNullOrEmpty(userEmail))
            {
                return GetDefaultAvatar();
            }

            var user = await _userManager.FindByEmailAsync(userEmail);
            if (user == null)
            {
                return GetDefaultAvatar();
            }

            if (user.Avatar != null && user.Avatar.Length > 0)
            {
                // Определяем MIME-тип на основе сигнатуры файла
                var mimeType = GetImageMimeType(user.Avatar);
                return File(user.Avatar, mimeType);
            }

            return GetDefaultAvatar();
        }

        private string GetImageMimeType(byte[] imageData)
        {
            // Простая проверка сигнатуры файла для определения типа
            if (imageData.Length > 2 && imageData[0] == 0xFF && imageData[1] == 0xD8)
                return "image/jpeg";
            if (imageData.Length > 8 && imageData[0] == 0x89 && imageData[1] == 0x50 && imageData[2] == 0x4E && imageData[3] == 0x47)
                return "image/png";
            if (imageData.Length > 4 && imageData[0] == 0x47 && imageData[1] == 0x49 && imageData[2] == 0x46)
                return "image/gif";
            
            return "image/jpeg"; // По умолчанию
        }

        private IActionResult GetDefaultAvatar()
        {
            var imagePath = Path.Combine(_env.WebRootPath, "Images", "default-profile-picture.png");
            if (System.IO.File.Exists(imagePath))
            {
                return PhysicalFile(imagePath, "image/png");
            }
            
            // Если файл по умолчанию не найден, вернуть пустое изображение
            return NotFound();
        }
    }
}
3. Обновление _LoginPartial.cshtml
Views/Shared/_LoginPartial.cshtml
html
@using Microsoft.AspNetCore.Identity
@using LabUI.Data
@inject SignInManager<AppUser> SignInManager
@inject UserManager<AppUser> UserManager

<ul class="navbar-nav">
@if (SignInManager.IsSignedIn(User))
{
    <li class="nav-item dropdown">
        <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
            <img src="@Url.Action("GetAvatar", "Image")" width="30" height="30" alt="User" class="rounded-circle" />
            @User.Identity?.Name
        </a>
        <ul class="dropdown-menu" aria-labelledby="navbarDropdown">
            <li>
                <div class="dropdown-item-text">
                    <img src="@Url.Action("GetAvatar", "Image")" width="50" height="50" alt="User" class="rounded-circle" />
                    @User.Identity?.Name
                </div>
            </li>
            <li><hr class="dropdown-divider"></li>
            <li>
                <form class="form-inline" asp-area="Identity" asp-page="/Account/Logout" asp-route-returnUrl="@Url.Action("Index", "Home", new { area = "" })">
                    <button type="submit" class="dropdown-item">Logout</button>
                </form>
            </li>
        </ul>
    </li>
}
else
{
    <li class="nav-item">
        <a class="nav-link text-dark" asp-area="Identity" asp-page="/Account/Register">Register</a>
    </li>
    <li class="nav-item">
        <a class="nav-link text-dark" asp-area="Identity" asp-page="/Account/Login">Login</a>
    </li>
}
</ul>
4. Обновление Program.cs
Program.cs
csharp
using LabUI.Data;
using LabUI.Services;
using Microsoft.AspNetCore.Identity;
using Microsoft.EntityFrameworkCore;

var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
var connectionString = builder.Configuration.GetConnectionString("DefaultConnection");
builder.Services.AddDbContext<ApplicationDbContext>(options =>
    options.UseSqlServer(connectionString));
builder.Services.AddDatabaseDeveloperPageExceptionFilter();

builder.Services.AddDefaultIdentity<AppUser>(options => options.SignIn.RequireConfirmedAccount = true)
    .AddEntityFrameworkStores<ApplicationDbContext>();
builder.Services.AddControllersWithViews();

// Регистрация кастомных сервисов
builder.Services.AddScoped<ICategoryService, MemoryCategoryService>();
builder.Services.AddScoped<IProductService, MemoryProductService>();

var app = builder.Build();

// Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
{
    app.UseMigrationsEndPoint();
}
else
{
    app.UseExceptionHandler("/Home/Error");
    app.UseHsts();
}

app.UseHttpsRedirection();
app.UseStaticFiles();

app.UseRouting();

app.UseAuthentication();
app.UseAuthorization();

app.MapControllerRoute(
    name: "default",
    pattern: "{controller=Home}/{action=Index}/{id?}");
app.MapRazorPages();

app.Run();
5. Обновление ApplicationDbContext
Убедитесь, что ваш ApplicationDbContext наследуется от IdentityDbContext<AppUser>:

Data/ApplicationDbContext.cs
csharp
using Microsoft.AspNetCore.Identity.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore;

namespace LabUI.Data
{
    public class ApplicationDbContext : IdentityDbContext<AppUser>
    {
        public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options)
            : base(options)
        {
        }
    }
}
6. Выполнение миграции
Если вы еще не выполнили миграцию для добавления поля Avatar, выполните в Package Manager Console:

bash
Add-Migration AddAvatarToAppUser
Update-Database
Основные изменения:
Заменен ApplicationUser на AppUser во всех файлах

Упрощена обработка аватара - теперь сохраняется только массив байтов без MIME-типа

Добавлен метод GetImageMimeType для автоматического определения типа изображения по сигнатуре файла

Обновлены все зависимости для работы с AppUser

Теперь ваш проект должен работать корректно с классом AppUser и полем Avatar.

Register.cshtml.cs
// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
#nullable disable

using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Text.Encodings.Web;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Authentication;
using Microsoft.AspNetCore.Authorization;
using LabUI.Data;
using Microsoft.AspNetCore.Identity;
using Microsoft.AspNetCore.Identity.UI.Services;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.RazorPages;
using Microsoft.AspNetCore.WebUtilities;
using Microsoft.Extensions.Logging;

namespace LabUI.Areas.Identity.Pages.Account
{
    public class RegisterModel : PageModel
    {
        private readonly SignInManager<AppUser> _signInManager;
        private readonly UserManager<AppUser> _userManager;
        private readonly IUserStore<AppUser> _userStore;
        private readonly IUserEmailStore<AppUser> _emailStore;
        private readonly ILogger<RegisterModel> _logger;
        private readonly IEmailSender _emailSender;

        public RegisterModel(
            UserManager<AppUser> userManager,
            IUserStore<AppUser> userStore,
            SignInManager<AppUser> signInManager,
            ILogger<RegisterModel> logger,
            IEmailSender emailSender)
        {
            _userManager = userManager;
            _userStore = userStore;
            _emailStore = GetEmailStore();
            _signInManager = signInManager;
            _logger = logger;
            _emailSender = emailSender;
        }

        /// <summary>
        ///     This API supports the ASP.NET Core Identity default UI infrastructure and is not intended to be used
        ///     directly from your code. This API may change or be removed in future releases.
        /// </summary>
        [BindProperty]
        public InputModel Input { get; set; }
        [BindProperty]

       
        public IFormFile? Avatar { get; set; }

        /// <summary>
        ///     This API supports the ASP.NET Core Identity default UI infrastructure and is not intended to be used
        ///     directly from your code. This API may change or be removed in future releases.
        /// </summary>
        public string ReturnUrl { get; set; }

        /// <summary>
        ///     This API supports the ASP.NET Core Identity default UI infrastructure and is not intended to be used
        ///     directly from your code. This API may change or be removed in future releases.
        /// </summary>
        public IList<AuthenticationScheme> ExternalLogins { get; set; }

        /// <summary>
        ///     This API supports the ASP.NET Core Identity default UI infrastructure and is not intended to be used
        ///     directly from your code. This API may change or be removed in future releases.
        /// </summary>
        public class InputModel
        {
            /// <summary>
            ///     This API supports the ASP.NET Core Identity default UI infrastructure and is not intended to be used
            ///     directly from your code. This API may change or be removed in future releases.
            /// </summary>
            [Required]
            [EmailAddress]
            [Display(Name = "Email")]
            public string Email { get; set; }

            /// <summary>
            ///     This API supports the ASP.NET Core Identity default UI infrastructure and is not intended to be used
            ///     directly from your code. This API may change or be removed in future releases.
            /// </summary>
            [Required]
            [StringLength(100, ErrorMessage = "The {0} must be at least {2} and at max {1} characters long.", MinimumLength = 6)]
            [DataType(DataType.Password)]
            [Display(Name = "Password")]
            public string Password { get; set; }

            /// <summary>
            ///     This API supports the ASP.NET Core Identity default UI infrastructure and is not intended to be used
            ///     directly from your code. This API may change or be removed in future releases.
            /// </summary>
            [DataType(DataType.Password)]
            [Display(Name = "Confirm password")]
            [Compare("Password", ErrorMessage = "The password and confirmation password do not match.")]
            public string ConfirmPassword { get; set; }
        }


        public async Task OnGetAsync(string returnUrl = null)
        {
            ReturnUrl = returnUrl;
            ExternalLogins = (await _signInManager.GetExternalAuthenticationSchemesAsync()).ToList();
        }

        public async Task<IActionResult> OnPostAsync(string returnUrl = null)
        {
            returnUrl ??= Url.Content("~/");
            ExternalLogins = (await _signInManager.GetExternalAuthenticationSchemesAsync()).ToList();
            if (ModelState.IsValid)
            {
                var user = CreateUser();

                await _userStore.SetUserNameAsync(user, Input.Email, CancellationToken.None);
                await _emailStore.SetEmailAsync(user, Input.Email, CancellationToken.None);

                if (Avatar != null)
                {
                    var stream = new MemoryStream();
                    await Avatar.CopyToAsync(stream);
                    user.Avatar = stream.ToArray();
                }
                var result = await _userManager.CreateAsync(user, Input.Password);
 
                if (result.Succeeded)
                {
                    _logger.LogInformation("User created a new account with password.");

                    var userId = await _userManager.GetUserIdAsync(user);
                    var code = await _userManager.GenerateEmailConfirmationTokenAsync(user);
                    code = WebEncoders.Base64UrlEncode(Encoding.UTF8.GetBytes(code));
                    var callbackUrl = Url.Page(
                        "/Account/ConfirmEmail",
                        pageHandler: null,
                        values: new { area = "Identity", userId = userId, code = code, returnUrl = returnUrl },
                        protocol: Request.Scheme);

                    await _emailSender.SendEmailAsync(Input.Email, "Confirm your email",
                        $"Please confirm your account by <a href='{HtmlEncoder.Default.Encode(callbackUrl)}'>clicking here</a>.");

                    if (_userManager.Options.SignIn.RequireConfirmedAccount)
                    {
                        return RedirectToPage("RegisterConfirmation", new { email = Input.Email, returnUrl = returnUrl });
                    }
                    else
                    {
                        await _signInManager.SignInAsync(user, isPersistent: false);
                        return LocalRedirect(returnUrl);
                    }
                }
                foreach (var error in result.Errors)
                {
                    ModelState.AddModelError(string.Empty, error.Description);
                }
            }

            // If we got this far, something failed, redisplay form
            return Page();
        }

        private AppUser CreateUser()
        {
            try
            {
                return Activator.CreateInstance<AppUser>();
            }
            catch
            {
                throw new InvalidOperationException($"Can't create an instance of '{nameof(AppUser)}'. " +
                    $"Ensure that '{nameof(AppUser)}' is not an abstract class and has a parameterless constructor, or alternatively " +
                    $"override the register page in /Areas/Identity/Pages/Account/Register.cshtml");
            }
        }

        private IUserEmailStore<AppUser> GetEmailStore()
        {
            if (!_userManager.SupportsUserEmail)
            {
                throw new NotSupportedException("The default UI requires a user store with email support.");
            }
            return (IUserEmailStore<AppUser>)_userStore;
        }
    }
}
Я вижу проблему - свойство Avatar объявлено отдельно от InputModel, но в форме привязки используется Input.Avatar. Нужно исправить это. Вот обновленный код:

Исправленный Register.cshtml.cs
csharp
// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
#nullable disable

using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Text.Encodings.Web;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Authentication;
using Microsoft.AspNetCore.Authorization;
using LabUI.Data;
using Microsoft.AspNetCore.Identity;
using Microsoft.AspNetCore.Identity.UI.Services;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.RazorPages;
using Microsoft.AspNetCore.WebUtilities;
using Microsoft.Extensions.Logging;

namespace LabUI.Areas.Identity.Pages.Account
{
    public class RegisterModel : PageModel
    {
        private readonly SignInManager<AppUser> _signInManager;
        private readonly UserManager<AppUser> _userManager;
        private readonly IUserStore<AppUser> _userStore;
        private readonly IUserEmailStore<AppUser> _emailStore;
        private readonly ILogger<RegisterModel> _logger;
        private readonly IEmailSender _emailSender;

        public RegisterModel(
            UserManager<AppUser> userManager,
            IUserStore<AppUser> userStore,
            SignInManager<AppUser> signInManager,
            ILogger<RegisterModel> logger,
            IEmailSender emailSender)
        {
            _userManager = userManager;
            _userStore = userStore;
            _emailStore = GetEmailStore();
            _signInManager = signInManager;
            _logger = logger;
            _emailSender = emailSender;
        }

        /// <summary>
        ///     This API supports the ASP.NET Core Identity default UI infrastructure and is not intended to be used
        ///     directly from your code. This API may change or be removed in future releases.
        /// </summary>
        [BindProperty]
        public InputModel Input { get; set; }

        /// <summary>
        ///     This API supports the ASP.NET Core Identity default UI infrastructure and is not intended to be used
        ///     directly from your code. This API may change or be removed in future releases.
        /// </summary>
        public string ReturnUrl { get; set; }

        /// <summary>
        ///     This API supports the ASP.NET Core Identity default UI infrastructure and is not intended to be used
        ///     directly from your code. This API may change or be removed in future releases.
        /// </summary>
        public IList<AuthenticationScheme> ExternalLogins { get; set; }

        /// <summary>
        ///     This API supports the ASP.NET Core Identity default UI infrastructure and is not intended to be used
        ///     directly from your code. This API may change or be removed in future releases.
        /// </summary>
        public class InputModel
        {
            /// <summary>
            ///     This API supports the ASP.NET Core Identity default UI infrastructure and is not intended to be used
            ///     directly from your code. This API may change or be removed in future releases.
            /// </summary>
            [Required]
            [EmailAddress]
            [Display(Name = "Email")]
            public string Email { get; set; }

            /// <summary>
            ///     This API supports the ASP.NET Core Identity default UI infrastructure and is not intended to be used
            ///     directly from your code. This API may change or be removed in future releases.
            /// </summary>
            [Required]
            [StringLength(100, ErrorMessage = "The {0} must be at least {2} and at max {1} characters long.", MinimumLength = 6)]
            [DataType(DataType.Password)]
            [Display(Name = "Password")]
            public string Password { get; set; }

            /// <summary>
            ///     This API supports the ASP.NET Core Identity default UI infrastructure and is not intended to be used
            ///     directly from your code. This API may change or be removed in future releases.
            /// </summary>
            [DataType(DataType.Password)]
            [Display(Name = "Confirm password")]
            [Compare("Password", ErrorMessage = "The password and confirmation password do not match.")]
            public string ConfirmPassword { get; set; }

            /// <summary>
            ///     Avatar image for the user
            /// </summary>
            [Display(Name = "Avatar")]
            public IFormFile Avatar { get; set; }
        }

        public async Task OnGetAsync(string returnUrl = null)
        {
            ReturnUrl = returnUrl;
            ExternalLogins = (await _signInManager.GetExternalAuthenticationSchemesAsync()).ToList();
        }

        public async Task<IActionResult> OnPostAsync(string returnUrl = null)
        {
            returnUrl ??= Url.Content("~/");
            ExternalLogins = (await _signInManager.GetExternalAuthenticationSchemesAsync()).ToList();
            if (ModelState.IsValid)
            {
                var user = CreateUser();

                await _userStore.SetUserNameAsync(user, Input.Email, CancellationToken.None);
                await _emailStore.SetEmailAsync(user, Input.Email, CancellationToken.None);

                // Обработка аватара
                if (Input.Avatar != null && Input.Avatar.Length > 0)
                {
                    using (var memoryStream = new MemoryStream())
                    {
                        await Input.Avatar.CopyToAsync(memoryStream);
                        user.Avatar = memoryStream.ToArray();
                    }
                }

                var result = await _userManager.CreateAsync(user, Input.Password);

                if (result.Succeeded)
                {
                    _logger.LogInformation("User created a new account with password.");

                    var userId = await _userManager.GetUserIdAsync(user);
                    var code = await _userManager.GenerateEmailConfirmationTokenAsync(user);
                    code = WebEncoders.Base64UrlEncode(Encoding.UTF8.GetBytes(code));
                    var callbackUrl = Url.Page(
                        "/Account/ConfirmEmail",
                        pageHandler: null,
                        values: new { area = "Identity", userId = userId, code = code, returnUrl = returnUrl },
                        protocol: Request.Scheme);

                    await _emailSender.SendEmailAsync(Input.Email, "Confirm your email",
                        $"Please confirm your account by <a href='{HtmlEncoder.Default.Encode(callbackUrl)}'>clicking here</a>.");

                    if (_userManager.Options.SignIn.RequireConfirmedAccount)
                    {
                        return RedirectToPage("RegisterConfirmation", new { email = Input.Email, returnUrl = returnUrl });
                    }
                    else
                    {
                        await _signInManager.SignInAsync(user, isPersistent: false);
                        return LocalRedirect(returnUrl);
                    }
                }
                foreach (var error in result.Errors)
                {
                    ModelState.AddModelError(string.Empty, error.Description);
                }
            }

            // If we got this far, something failed, redisplay form
            return Page();
        }

        private AppUser CreateUser()
        {
            try
            {
                return Activator.CreateInstance<AppUser>();
            }
            catch
            {
                throw new InvalidOperationException($"Can't create an instance of '{nameof(AppUser)}'. " +
                    $"Ensure that '{nameof(AppUser)}' is not an abstract class and has a parameterless constructor, or alternatively " +
                    $"override the register page in /Areas/Identity/Pages/Account/Register.cshtml");
            }
        }

        private IUserEmailStore<AppUser> GetEmailStore()
        {
            if (!_userManager.SupportsUserEmail)
            {
                throw new NotSupportedException("The default UI requires a user store with email support.");
            }
            return (IUserEmailStore<AppUser>)_userStore;
        }
    }
}
Обновленный Register.cshtml
Также нужно обновить представление, чтобы использовать Input.Avatar:

html
@page
@model RegisterModel
@{
    ViewData["Title"] = "Register";
}

<h1>@ViewData["Title"]</h1>

<div class="row">
    <div class="col-md-4">
        <form asp-route-returnUrl="@Model.ReturnUrl" method="post" enctype="multipart/form-data">
            <h4>Create a new account.</h4>
            <hr />
            <div asp-validation-summary="All" class="text-danger"></div>
            <div class="form-group">
                <label asp-for="Input.Email"></label>
                <input asp-for="Input.Email" class="form-control" />
                <span asp-validation-for="Input.Email" class="text-danger"></span>
            </div>
            <div class="form-group">
                <label asp-for="Input.Password"></label>
                <input asp-for="Input.Password" class="form-control" />
                <span asp-validation-for="Input.Password" class="text-danger"></span>
            </div>
            <div class="form-group">
                <label asp-for="Input.ConfirmPassword"></label>
                <input asp-for="Input.ConfirmPassword" class="form-control" />
                <span asp-validation-for="Input.ConfirmPassword" class="text-danger"></span>
            </div>
            <div class="mb-3">
                <label asp-for="Input.Avatar" class="form-label">Avatar</label>
                <input asp-for="Input.Avatar" class="form-control" type="file" />
                <span asp-validation-for="Input.Avatar" class="text-danger"></span>
            </div>
            <button type="submit" class="btn btn-primary">Register</button>
        </form>
    </div>
    <div class="col-md-6 col-md-offset-2">
        <section>
            <h3>Use another service to register.</h3>
            <hr />
            @{
                if ((Model.ExternalLogins?.Count ?? 0) == 0)
                {
                    <div>
                        <p>
                            There are no external authentication services configured. See this <a href="https://go.microsoft.com/fwlink/?LinkID=532715">article
                            about setting up this ASP.NET Core application to support logging in via external services</a>.
                        </p>
                    </div>
                }
                else
                {
                    <form id="external-account" asp-page="./ExternalLogin" asp-route-returnUrl="@Model.ReturnUrl" method="post" class="form-horizontal">
                        <div>
                            <p>
                                @foreach (var provider in Model.ExternalLogins)
                                {
                                    <button type="submit" class="btn btn-primary" name="provider" value="@provider.Name" title="Log in using your @provider.DisplayName account">@provider.DisplayName</button>
                                }
                            </p>
                        </div>
                    </form>
                }
            }
        </section>
    </div>
</div>

@section Scripts {
    <partial name="_ValidationScriptsPartial" />
}
Основные исправления:
Переместил свойство Avatar внутрь класса InputModel - это исправляет проблему привязки данных

Удалил отдельное свойство Avatar из основной модели страницы

Добавил атрибут [Display] для свойства Avatar

Добавил using для MemoryStream для правильной работы с потоками

Обновил представление чтобы использовать Input.Avatar

Теперь при регистрации файл аватара будет правильно привязываться к модели и сохраняться в базе данных.

ImageController.cs
using LabUI.Data;
using Microsoft.AspNetCore.Identity;
using Microsoft.AspNetCore.Mvc;

namespace LabUI.Controllers
{
    public class ImageController(UserManager<AppUser> um) : Controller
    {
        public async Task <IActionResult> GetAvatar()
        {
            var email = User.Identity.Name;
            var user = await um.FindByEmailAsync(email);

            if (user.Avatar != null)
                return File(user.Avatar, "images/*");
          

            return File("images/123.jpg", "images/*");
        }
    }
}
В вашем ImageController есть несколько проблем. Вот исправленная версия:

Исправленный ImageController.cs
csharp
using LabUI.Data;
using Microsoft.AspNetCore.Identity;
using Microsoft.AspNetCore.Mvc;
using System.Security.Claims;

namespace LabUI.Controllers
{
    public class ImageController : Controller
    {
        private readonly UserManager<AppUser> _userManager;
        private readonly IWebHostEnvironment _env;

        public ImageController(UserManager<AppUser> userManager, IWebHostEnvironment env)
        {
            _userManager = userManager;
            _env = env;
        }

        public async Task<IActionResult> GetAvatar()
        {
            // Получаем email из claims
            var userEmail = User.FindFirst(ClaimTypes.Email)?.Value ?? User.Identity?.Name;
            
            if (string.IsNullOrEmpty(userEmail))
            {
                return GetDefaultAvatar();
            }

            var user = await _userManager.FindByEmailAsync(userEmail);
            if (user == null)
            {
                return GetDefaultAvatar();
            }

            if (user.Avatar != null && user.Avatar.Length > 0)
            {
                // Определяем MIME-тип на основе сигнатуры файла
                var mimeType = GetImageMimeType(user.Avatar);
                return File(user.Avatar, mimeType);
            }

            return GetDefaultAvatar();
        }

        private string GetImageMimeType(byte[] imageData)
        {
            if (imageData.Length < 4)
                return "image/jpeg";

            // Проверяем сигнатуры файлов для определения типа
            if (imageData[0] == 0xFF && imageData[1] == 0xD8 && imageData[2] == 0xFF)
                return "image/jpeg";
            
            if (imageData[0] == 0x89 && imageData[1] == 0x50 && imageData[2] == 0x4E && imageData[3] == 0x47)
                return "image/png";
            
            if (imageData[0] == 0x47 && imageData[1] == 0x49 && imageData[2] == 0x46)
                return "image/gif";
            
            if (imageData[0] == 0x42 && imageData[1] == 0x4D)
                return "image/bmp";
            
            // По умолчанию возвращаем jpeg
            return "image/jpeg";
        }

        private IActionResult GetDefaultAvatar()
        {
            var imagePath = Path.Combine(_env.WebRootPath, "images", "123.jpg");
            if (System.IO.File.Exists(imagePath))
            {
                // Определяем MIME-тип для файла по умолчанию
                var fileExtension = Path.GetExtension(imagePath).ToLower();
                var mimeType = fileExtension switch
                {
                    ".jpg" or ".jpeg" => "image/jpeg",
                    ".png" => "image/png",
                    ".gif" => "image/gif",
                    ".bmp" => "image/bmp",
                    _ => "image/jpeg"
                };
                
                return PhysicalFile(imagePath, mimeType);
            }
            
            // Если файл по умолчанию не найден, возвращаем 404
            return NotFound("Default avatar image not found");
        }
    }
}
Альтернативная упрощенная версия (если нужен более простой код):
csharp
using LabUI.Data;
using Microsoft.AspNetCore.Identity;
using Microsoft.AspNetCore.Mvc;
using System.Security.Claims;

namespace LabUI.Controllers
{
    public class ImageController : Controller
    {
        private readonly UserManager<AppUser> _userManager;
        private readonly IWebHostEnvironment _env;

        public ImageController(UserManager<AppUser> userManager, IWebHostEnvironment env)
        {
            _userManager = userManager;
            _env = env;
        }

        public async Task<IActionResult> GetAvatar()
        {
            var userEmail = User.FindFirst(ClaimTypes.Email)?.Value ?? User.Identity?.Name;
            
            if (!string.IsNullOrEmpty(userEmail))
            {
                var user = await _userManager.FindByEmailAsync(userEmail);
                if (user?.Avatar != null && user.Avatar.Length > 0)
                {
                    // Предполагаем, что это JPEG (можно изменить на нужный тип)
                    return File(user.Avatar, "image/jpeg");
                }
            }

            // Возвращаем аватар по умолчанию
            var defaultImagePath = Path.Combine(_env.WebRootPath, "images", "123.jpg");
            if (System.IO.File.Exists(defaultImagePath))
            {
                return PhysicalFile(defaultImagePath, "image/jpeg");
            }

            return NotFound();
        }
    }
}
Основные исправления:
Правильное получение email пользователя - используем ClaimTypes.Email или User.Identity.Name

Проверка на null - проверяем, что пользователь существует и у него есть аватар

Правильные MIME-типы - вместо "images/*" используем конкретные MIME-типы (image/jpeg, image/png и т.д.)

Добавлена обработка ошибок - если пользователь не найден или аватар отсутствует, возвращаем аватар по умолчанию

Использование IWebHostEnvironment - для правильного построения пути к файлам в wwwroot

Проверка существования файла - перед возвратом файла по умолчанию

Также убедитесь, что:
В папке wwwroot/images существует файл 123.jpg

В AppUser поле Avatar может быть nullable:

csharp
public byte[]? Avatar { get; set; }
Теперь контроллер будет корректно работать и возвращать аватар пользователя или изображение по умолчанию.